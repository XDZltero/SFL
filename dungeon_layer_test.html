<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<title>副本戰鬥</title>
<link rel="icon" href="favicon.ico" />
<link href="css/style.css" rel="stylesheet"/>
<link href="css/dungeon_layer_winning.css" rel="stylesheet"/>
<link href="css/dungeon_layer.css" rel="stylesheet"/>
<style>
.section::before {
  animation: none !important;
  background: none !important;
}

/* 完全零間隙的詳細說明容器 */
.stat-item-container {
  position: relative;
  margin: 0;
  padding: 0;
}

.stat-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 0;
  padding: 8px 12px;
  background: rgba(0, 255, 255, 0.05);
  border: 1px solid rgba(0, 255, 255, 0.1);
  border-bottom: none; /* 移除底部邊框避免重複 */
  font-family: 'Orbitron', sans-serif;
  font-weight: 600;
  font-size: 0.9em;
  transition: all 0.3s ease;
  cursor: pointer;
  position: relative;
}

/* 最後一個項目添加底部邊框 */
.stat-item-container:last-child .stat-item {
  border-bottom: 1px solid rgba(0, 255, 255, 0.1);
}

/* 第一個項目的圓角 */
.stat-item-container:first-child .stat-item {
  border-radius: 6px 6px 0 0;
}

/* 最後一個項目的圓角（如果沒有展開詳細說明） */
.stat-item-container:last-child .stat-item {
  border-radius: 0 0 6px 6px;
}

/* 只有一個項目時的完整圓角 */
.stat-item-container:first-child:last-child .stat-item {
  border-radius: 6px;
}

.stat-item:hover {
  background: rgba(0, 255, 255, 0.1);
  border-color: rgba(0, 255, 255, 0.3);
  transform: translateX(2px);
  z-index: 2;
}

.stat-item span:first-child {
  color: #ffd93d;
  text-shadow: 0 0 5px rgba(255, 217, 61, 0.5);
  flex: 1;
}

.stat-item span:last-child {
  color: #00ffff;
  text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
  font-weight: 700;
  text-align: right;
}

/* 完全零間隙的詳細說明容器 */
.stat-detail {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  background: linear-gradient(135deg, rgba(0, 255, 255, 0.08), rgba(0, 255, 255, 0.02));
  border-left: 1px solid rgba(0, 255, 255, 0.1);
  border-right: 1px solid rgba(0, 255, 255, 0.1);
  border-bottom: 1px solid rgba(0, 255, 255, 0.1);
  margin: 0;
  padding: 0;
  border-top: none;
}

.stat-detail.expanded {
  max-height: 200px;
}

.stat-detail-content {
  padding: 10px 12px;
  font-size: 0.75em;
  color: #b8e6ff;
  line-height: 1.5;
  text-shadow: 0 0 3px rgba(184, 230, 255, 0.6);
  margin: 0;
  /* 確保內容不會在收起時顯示 */
  opacity: 0;
  transform: translateY(-8px);
  transition: opacity 0.3s ease 0.1s, transform 0.3s ease 0.1s;
}

.stat-detail.expanded .stat-detail-content {
  opacity: 1;
  transform: translateY(0);
}

/* 怪物屬性完全零間隙設計 */
.monster-stat-container {
  position: relative;
  margin: 0;
  padding: 0;
}

.monster-stat-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 10px;
  background: rgba(255, 107, 107, 0.1);
  border: 1px solid rgba(255, 107, 107, 0.2);
  border-bottom: none;
  font-family: 'Orbitron', sans-serif;
  font-weight: 600;
  font-size: 0.85em;
  transition: all 0.3s ease;
  margin: 0;
  cursor: pointer;
}

/* 最後一個怪物項目添加底部邊框 */
.monster-stat-container:last-child .monster-stat-item {
  border-bottom: 1px solid rgba(255, 107, 107, 0.2);
}

/* 第一個怪物項目的圓角 */
.monster-stat-container:first-child .monster-stat-item {
  border-radius: 6px 6px 0 0;
}

/* 最後一個怪物項目的圓角 */
.monster-stat-container:last-child .monster-stat-item {
  border-radius: 0 0 6px 6px;
}

/* 只有一個怪物項目時的完整圓角 */
.monster-stat-container:first-child:last-child .monster-stat-item {
  border-radius: 6px;
}

.monster-stat-item:hover {
  background: rgba(255, 107, 107, 0.2);
  border-color: rgba(255, 107, 107, 0.4);
  transform: translateX(2px);
  z-index: 2;
}

.monster-stat-item span:first-child {
  color: #ffd93d;
  text-shadow: 0 0 5px rgba(255, 217, 61, 0.5);
}

.monster-stat-item span:last-child {
  color: #fff8b0;
  text-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
  font-weight: 700;
}

.monster-element-detail {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  background: linear-gradient(135deg, rgba(255, 107, 107, 0.08), rgba(255, 107, 107, 0.02));
  border-left: 1px solid rgba(255, 107, 107, 0.2);
  border-right: 1px solid rgba(255, 107, 107, 0.2);
  border-bottom: 1px solid rgba(255, 107, 107, 0.2);
  margin: 0;
  padding: 0;
  border-top: none;
}

.monster-element-detail.expanded {
  max-height: 300px;
}

.monster-element-detail-content {
  padding: 10px 12px;
  font-size: 0.8em;
  color: #ffd1d1;
  line-height: 1.5;
  text-shadow: 0 0 3px rgba(255, 209, 209, 0.3);
  white-space: pre-line;
  opacity: 0;
  transform: translateY(-8px);
  transition: opacity 0.3s ease 0.1s, transform 0.3s ease 0.1s;
}

.monster-element-detail.expanded .monster-element-detail-content {
  opacity: 1;
  transform: translateY(0);
}

/* BOSS模式適配 */
body.boss-mode .monster-stat-item {
  background: rgba(255, 69, 0, 0.15);
  border-color: rgba(255, 69, 0, 0.3);
}

body.boss-mode .monster-stat-item:hover {
  background: rgba(255, 69, 0, 0.25);
  border-color: rgba(255, 69, 0, 0.5);
}

body.boss-mode .monster-stat-item span:last-child {
  color: #ffd700;
  text-shadow: 0 0 6px rgba(255, 215, 0, 0.8);
}

body.boss-mode .monster-element-detail {
  background: linear-gradient(135deg, rgba(255, 69, 0, 0.1), rgba(255, 69, 0, 0.05));
  border-left-color: rgba(255, 69, 0, 0.3);
  border-right-color: rgba(255, 69, 0, 0.3);
  border-bottom-color: rgba(255, 69, 0, 0.3);
}

body.boss-mode .monster-element-detail-content {
  color: #ffb84d;
  text-shadow: 0 0 5px rgba(255, 184, 77, 0.4);
}

/* BOSS裝飾標題 */
.boss-title-decoration {
  text-align: center;
  font-size: 1.2em;
  font-weight: 900;
  color: #ff4500;
  text-shadow: 0 0 15px rgba(255, 69, 0, 0.8);
  margin-bottom: 8px;
  padding: 5px;
  background: linear-gradient(135deg, rgba(255, 69, 0, 0.1), rgba(255, 69, 0, 0.05));
  border-radius: 6px;
  border: 1px solid rgba(255, 69, 0, 0.3);
}

/* 展開控制按鈕 */
.detail-toggle-btn {
  background: rgba(0, 255, 255, 0.1);
  border: 1px solid rgba(0, 255, 255, 0.3);
  border-radius: 6px;
  padding: 6px 12px;
  font-size: 0.7em;
  color: #00ffff;
  cursor: pointer;
  transition: all 0.3s ease;
  font-family: 'Orbitron', sans-serif;
  font-weight: 600;
  white-space: nowrap;
  flex-shrink: 0;
}

.detail-toggle-btn:hover {
  background: rgba(0, 255, 255, 0.2);
  transform: scale(1.02);
  box-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
}

.detail-toggle-btn.active {
  background: rgba(0, 255, 255, 0.25);
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
  border-color: rgba(0, 255, 255, 0.6);
}

/* 展開時圓角處理 - 使用類別控制 */
.stat-item-container.has-expanded .stat-item {
  border-radius: 6px 6px 0 0 !important;
  border-bottom: 1px solid rgba(0, 255, 255, 0.1);
}

.stat-detail.expanded {
  border-radius: 0 0 6px 6px;
  border-bottom: 1px solid rgba(0, 255, 255, 0.1);
}

.monster-stat-container.has-expanded .monster-stat-item {
  border-radius: 6px 6px 0 0 !important;
  border-bottom: 1px solid rgba(255, 107, 107, 0.2);
}

.monster-element-detail.expanded {
  border-radius: 0 0 6px 6px;
  border-bottom: 1px solid rgba(255, 107, 107, 0.2);
}

/* BOSS模式下的展開樣式 */
body.boss-mode .monster-stat-container.has-expanded .monster-stat-item {
  border-bottom-color: rgba(255, 69, 0, 0.3);
}

body.boss-mode .monster-element-detail.expanded {
  border-bottom-color: rgba(255, 69, 0, 0.3);
}

/* 玩家信息容器零間距 */
.player-info-container {
  margin: 0;
  padding: 0;
}

/* 玩家名稱和按鈕的容器 */
.player-name-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 10px 0;
  gap: 15px;
}

.player-name {
  color: #00ffff;
  text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
  font-family: 'Orbitron', sans-serif;
  font-size: 1.3em;
  margin: 0;
  flex: 1;
}

/* 怪物信息容器零間距 */
.monster-info-container {
  margin: 0;
  padding: 0;
}

.monster-name {
  color: #ff6b6b;
  text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
  text-align: center;
  margin: 10px 0;
  font-family: 'Orbitron', sans-serif;
  font-size: 1.3em;
}

.monster-image {
  display: block;
  margin: 10px auto;
  border-radius: 8px;
  border: 2px solid rgba(255, 107, 107, 0.3);
}

.monster-description {
  color: #ffd1d1;
  text-align: center;
  margin: 10px 0;
  padding: 10px;
  background: rgba(255, 107, 107, 0.05);
  border-radius: 6px;
  line-height: 1.4;
}

/* 完全消除所有間隙 */
.stats-container > *,
.monster-stats > * {
  margin: 0;
  padding: 0;
}

.stats-container,
.monster-stats {
  margin: 0;
  padding: 0;
}

/* 確保展開內容不會影響其他元素 */
.stat-item-container,
.monster-stat-container {
  isolation: isolate;
  margin: 0;
  padding: 0;
}

/* 響應式設計 */
@media (max-width: 768px) {
  .detail-toggle-btn {
    padding: 5px 8px;
    font-size: 0.6em;
  }
  
  .player-name-container {
    gap: 10px;
    margin: 8px 0;
  }
  
  .player-name {
    font-size: 1.1em;
  }
  
  .stat-detail-content,
  .monster-element-detail-content {
    font-size: 0.7em;
    padding: 8px 10px;
  }
  
  .stat-detail.expanded {
    max-height: 150px;
  }
  
  .monster-element-detail.expanded {
    max-height: 250px;
  }
  
  .stat-item,
  .monster-stat-item {
    padding: 6px 8px;
    font-size: 0.8em;
  }
  
  .monster-name {
    font-size: 1.1em;
    margin: 8px 0;
  }
}

/* 超小螢幕適配 */
@media (max-width: 480px) {
  .player-name-container {
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }
  
  .detail-toggle-btn {
    width: auto;
    padding: 6px 10px;
    font-size: 0.65em;
  }
  
  .player-name {
    text-align: center;
    font-size: 1em;
  }
}
</style>
</head>
<body>
<!-- 勝利特效遮罩 -->
<div id="victoryOverlay" class="victory-overlay">
  <div class="fireworks" id="fireworksContainer"></div>
  <div class="victory-content">
    <div class="victory-icon">🏆</div>
    <div class="victory-title">Victory</div>
    <div class="victory-message">🌟成功通關副本🌟</div>
    <button class="effect-button" onclick="hideVictoryEffect()">繼續</button>
  </div>
</div>

<!-- 失敗特效遮罩 -->
<div id="defeatOverlay" class="defeat-overlay">
  <div class="debris" id="debrisContainer"></div>
  <div class="defeat-content">
    <div class="defeat-icon">💀</div>
    <div class="defeat-title">戰敗</div>
    <div class="defeat-message" id="defeatMessage">失敗乃成功之母，再接再厲！</div>
    <button class="effect-button" onclick="hideDefeatEffect()">繼續</button>
  </div>
</div>

<!-- 頁面載入遮罩 -->
<div id="loadingOverlay">
<div class="particles" id="pageParticles"></div>
<div class="battle-loading-container">
<div class="battle-icon">🏰</div>
<div class="battle-title normal-title">進入副本</div>
<div class="loading-text" id="pageLoadingText">正在載入副本資料...</div>
<div class="progress-container">
<div class="progress-bar" id="pageProgressBar"></div>
</div>
<div class="progress-text" id="pageProgressText">0%</div>
<div class="battle-tips">
        🗡️ 升級卡片通關會更容易！<br/>
        📊 記得配置能力點與技能！
      </div>
</div>
</div>

<!-- 戰鬥載入遮罩 -->
<div id="battleLoadingOverlay">
<div class="particles" id="particles"></div>
<div class="battle-loading-container">
<div class="battle-icon" id="battleIcon">⚔️</div>
<div class="battle-title" id="battleTitle">戰鬥準備中</div>
<div class="loading-text" id="loadingText">正在分析戰況...</div>
<div class="progress-container" id="progressContainer">
<div class="progress-bar" id="progressBar"></div>
</div>
<div class="progress-text" id="progressText">0%</div>
<div class="battle-tips" id="battleTips">
        💡 戰鬥小提示：善用屬性克制關係可以提高勝率！<br/>
        🛡️ 記得切換不同技能來應對不同關卡
      </div>
</div>
</div>

<div id="content">
<div class="section" id="userInfo">🧍 角色資訊載入中...</div>
<div class="section" id="monsterInfo">👹 怪物資訊載入中...</div>
<div class="section"><strong>📜 戰鬥紀錄</strong><pre id="logArea"></pre></div>
</div>

<div id="footer">
<button id="battleBtn" onclick="startBattle()">開始戰鬥</button>
<button id="retryBtn" style="display:none" onclick="retryBattle()">再戰一次</button>
<button id="nextBtn" style="display:none">下一層</button>
<button id="leaveBtn" onclick="leaveDungeon()" style="display:none">離開副本</button>
</div>

<script type="module">
import { auth, SecureAPI, PerformanceMonitor } from "./js/firebase-init.js";
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

const API_BASE = "https://sfl-9cb8.onrender.com";

// 全局變量
let currentDungeon = null;
let currentLayer = null;
let currentMonster = null;
let userStatus = null;
let dungeonData = null;
let detailsExpanded = false;

// 詳細說明 tooltips
const tooltips = {
  level: "角色的當前等級。等級差距會影響戰鬥傷害：最多7等差距時傷害變為1.5倍或0.5倍。",
  exp: "角色的經驗值與升級進度。透過戰鬥獲得經驗值，累積足夠經驗值後會自動升級。不同怪物給予的經驗值不同，高等級怪物給予更多經驗值。",
  hp: "玩家的總生命值，決定角色的生存能力。當生命值降至0時戰鬥失敗。",
  attack: "決定對敵人造成傷害的基礎數值。攻擊力越高，傷害越大。會受到屬性克制、技能倍率、等級差距等因素影響。",
  shield: "減少受到傷害的防護值。每點護盾值減少0.1%傷害，最多99%。可透過護盾穿透降低效果，提供穩定的傷害減免。",
  luck: "影響迴避率、物品掉落率的幸運值。每點幸運提供額外0.2%迴避率加成(不直接顯示在迴避率上)，同時提升物品掉落及額外掉落機率。",
  accuracy: "攻擊命中敵人的機率，會與敵人迴避率相抗(命中率-迴避率)。命中率不足會導致失去本次攻擊傷害。",
  evade: "閃避敵人攻擊的機率，數值越高越容易完全無視敵人的攻擊，最高99%。迴避成功時完全無視該次攻擊傷害。",
  atk_speed: "決定戰鬥中的出手順序與頻率。攻擊速度高的一方會優先行動，並可能在一回合內進行多次攻擊。速度差距越大，優勢方的行動次數越多。並且進而加快技能冷卻回合。",
  other_bonus: "額外傷害加成，按百分比增加最終傷害。這是一個倍率加成，會在所有其他計算完成後套用。",
  penetrate: "無視敵人護盾值的能力。穿透值會直接扣除敵人的有效護盾值，是突破高防禦敵人的關鍵屬性。每點穿透可無視1點敵人護盾。",
  stat_points: "可用於提升基礎能力值的點數。每升級獲得5點。可分配到生命值(+5/點)、攻擊力(+1/點)或幸運值(+1/點)。",
  skill_points: "可用於升級技能的點數。每升級獲得3點。"
};

// URL 參數解析
function getURLParams() {
  const params = new URLSearchParams(window.location.search);
  return {
    dungeon: params.get("dungeon"),
    layer: params.get("layer")
  };
}

// 工具函數
function percent(val) {
  return (val * 100).toFixed(1) + '%';
}

function showLoading(show) {
  const loading = document.getElementById("loadingOverlay");
  if (loading) loading.style.display = show ? "flex" : "none";
}

function showBattleLoading(show, isBoss = false) {
  const battleLoading = document.getElementById("battleLoadingOverlay");
  if (!battleLoading) return;
  
  battleLoading.style.display = show ? "flex" : "none";
  
  if (show) {
    battleLoading.className = isBoss ? "boss-battle" : "";
    const title = document.getElementById("battleTitle");
    const icon = document.getElementById("battleIcon");
    const tips = document.getElementById("battleTips");
    
    if (isBoss) {
      if (title) title.textContent = "BOSS戰鬥準備中";
      if (icon) icon.textContent = "👑";
      if (tips) tips.innerHTML = "⚔️ BOSS戰鬥即將開始！<br/>🔥 運用你的最強技能組合！";
      title?.classList.add("boss");
      icon?.classList.add("boss");
      tips?.classList.add("boss");
    } else {
      if (title) title.textContent = "戰鬥準備中";
      if (icon) icon.textContent = "⚔️";
      if (tips) tips.innerHTML = "💡 戰鬥小提示：善用屬性克制關係可以提高勝率！<br/>🛡️ 記得切換不同技能來應對不同關卡";
      title?.classList.remove("boss");
      icon?.classList.remove("boss");
      tips?.classList.remove("boss");
    }
  }
}

const elementMap = {
  "none": "無",
  "phy": "物理", 
  "pyro": "火",
  "hydro": "水",
  "electro": "雷",
  "nature": "自然",
  "light": "光",
  "dark": "暗",
  "all": "全"
};

// 屬性克制說明生成
function generateElementDescription(elements) {
  const descriptions = [];
  
  elements.forEach(element => {
    switch(element) {
      case "pyro":
      case "火":
        descriptions.push("🔥 火屬性");
        descriptions.push("優勢：水屬性、全屬性 (+25% 傷害)");
        descriptions.push("劣勢：自然屬性 (-25% 傷害)");
        break;
      case "hydro":
      case "水":
        descriptions.push("💧 水屬性");
        descriptions.push("優勢： 雷屬性、全屬性 (+25% 傷害)");
        descriptions.push("劣勢： 火屬性 (-25% 傷害)");
        break;
      case "electro":
      case "雷":
        descriptions.push("⚡ 雷屬性");
        descriptions.push("優勢：自然屬性、全屬性 (+25% 傷害)");
        descriptions.push("劣勢：水屬性 (-25% 傷害)");
        break;
      case "nature":
      case "自然":
        descriptions.push("🌿 自然屬性");
        descriptions.push("優勢：火屬性、全屬性 (+25% 傷害)");
        descriptions.push("劣勢：雷屬性 (-25% 傷害)");
        break;
      case "light":
      case "光":
        descriptions.push("✨ 光屬性");
        descriptions.push("優勢：暗屬性、全屬性 (+25% 傷害)");
        break;
      case "dark":
      case "暗":
        descriptions.push("🌑 暗屬性");
        descriptions.push("優勢：光屬性、全屬性 (+25% 傷害)");
        break;
      case "all":
      case "全":
        descriptions.push("🌟 全屬性");
        descriptions.push("  └ 劣勢：其他屬性 (-25% 傷害)");
        break;
      case "none":
      case "無":
        descriptions.push("⚪ 無屬性");
        descriptions.push("優勢：全屬性 (+25% 傷害)");
        break;
      default:
        descriptions.push(`${elementMap[element] || element}屬性`);
    }
  });
  
  if (elements.length > 1) {
    descriptions.push("");
    descriptions.push("【複數屬性機制】");
    descriptions.push("• 擁有多個屬性時，傷害計算將取所有屬性克制關係平均值");
    descriptions.push("• 例如：火水雙屬性怪物被雷屬性攻擊時");
    descriptions.push("  - 雷→火：100%傷害(無克制)");
    descriptions.push("  - 雷→水：125%傷害(克制)");
    descriptions.push("  - 最終傷害：(100% + 125%) ÷ 2 = 112.5%");
  }
  
  return descriptions.join("\n");
}

// 詳細說明展開/收起控制
function toggleDetails() {
  detailsExpanded = !detailsExpanded;
  const button = document.querySelector('.detail-toggle-btn');
  
  if (button) {
    button.textContent = detailsExpanded ? '收起詳細說明' : '顯示詳細說明';
    button.classList.toggle('active', detailsExpanded);
  }
  
  // 控制玩家詳細說明
  const playerDetails = document.querySelectorAll('.stat-detail');
  const playerContainers = document.querySelectorAll('.stat-item-container');
  
  playerDetails.forEach((detail, index) => {
    detail.classList.toggle('expanded', detailsExpanded);
    // 為包含詳細說明的容器添加類別
    if (playerContainers[index] && detail.querySelector('.stat-detail-content')) {
      playerContainers[index].classList.toggle('has-expanded', detailsExpanded);
    }
  });
  
  // 控制怪物屬性詳細說明
  const monsterDetail = document.querySelector('.monster-element-detail');
  const monsterContainer = monsterDetail?.closest('.monster-stat-container');
  
  if (monsterDetail) {
    monsterDetail.classList.toggle('expanded', detailsExpanded);
    if (monsterContainer) {
      monsterContainer.classList.toggle('has-expanded', detailsExpanded);
    }
  }
}

// 設定全域函數
window.toggleDetails = toggleDetails;

// 格式化玩家狀態
function formatStats(data) {
  const b = data.base_stats;
  const e = data.equipment_bonus || {};
  
  const getValue = (key) => (b[key] || 0) + (e[key] || 0);
  const getFormatted = (key) => {
    const isPercent = ["evade", "accuracy", "other_bonus"].includes(key);
    const total = getValue(key);
    const base = b[key] || 0;
    const bonus = e[key] || 0;
    
    if (isPercent) {
      return {
        total: `${percent(total)}`,
        detail: `${percent(base)} + ${percent(bonus)}`
      };
    } else {
      return {
        total: total.toString(),
        detail: `${base} + ${bonus}`
      };
    }
  };

  const statsList = [
    { key: "level", label: "等級", value: data.level },
    { key: "exp", label: "經驗值", value: `${data.exp}` },
    { key: "hp", label: "生命值" },
    { key: "attack", label: "攻擊力" },
    { key: "shield", label: "護盾值" },
    { key: "luck", label: "幸運值" },
    { key: "accuracy", label: "命中率" },
    { key: "evade", label: "迴避率" },
    { key: "atk_speed", label: "攻擊速度" },
    { key: "other_bonus", label: "額外傷害加成" },
    { key: "penetrate", label: "護盾穿透" },
    { key: "stat_points", label: "剩餘能力值點數", value: data.stat_points },
    { key: "skill_points", label: "剩餘技能點", value: data.skill_points }
  ];

  let html = `
    <div class="player-info-container">
      <div class="player-name-container">
        <h3 class="player-name">👤 ${data.nickname}</h3>
        <button class="detail-toggle-btn" onclick="toggleDetails()">${detailsExpanded ? '收起詳細說明' : '顯示詳細說明'}</button>
      </div>
      <div class="stats-container">
  `;
  
  statsList.forEach(({ key, label, value }) => {
    html += `<div class="stat-item-container">`;
    
    if (value !== undefined) {
      html += `<div class="stat-item">
                 <span>${label}:</span>
                 <span>${value}</span>
               </div>`;
    } else if (["hp", "attack", "shield", "penetrate", "luck", "accuracy", "evade", "atk_speed", "other_bonus"].includes(key)) {
      const formatted = getFormatted(key);
      html += `<div class="stat-item">
                 <span>${label}:</span>
                 <span>${formatted.total} (${formatted.detail})</span>
               </div>`;
    }
    
    if (tooltips[key]) {
      html += `<div class="stat-detail ${detailsExpanded ? 'expanded' : ''}">
                 <div class="stat-detail-content">${tooltips[key]}</div>
               </div>`;
    }
    
    html += `</div>`;
  });
  
  html += `
      </div>
    </div>`;
  return html;
}

// 格式化怪物資訊
function formatMonsterInfo(mon, isLastLayer) {
  const description = (mon.info || '').replace(/\/n/g, '\n');
  
  const elementText = Array.isArray(mon.element) 
    ? mon.element.map(e => elementMap[e] || e).join("、") 
    : (elementMap[mon.element] || mon.element);

  let containerClass = "monster-info-container";
  let bossTitle = "";
  
  if (isLastLayer) {
    containerClass += " boss";
    bossTitle = '<div class="boss-title-decoration">BOSS</div>';
  }

  const monsterPenetrate = mon.stats.penetrate || 0;
  const elements = Array.isArray(mon.element) ? mon.element : [mon.element];
  const elementDescription = generateElementDescription(elements);

  const html = `
    <div class="${containerClass}">
      ${bossTitle}
      <h2 class="monster-name">${mon.name}</h2>
      <img src="${mon.image_url}" class="monster-image" width="200">
      <div class="monster-description">${description}</div>
      <div class="monster-stats">
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>等級：</span>
            <span>${mon.level}</span>
          </div>
        </div>
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>屬性：</span>
            <span>${elementText}</span>
          </div>
          <div class="monster-element-detail ${detailsExpanded ? 'expanded' : ''}">
            <div class="monster-element-detail-content">${elementDescription}</div>
          </div>
        </div>
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>生命值：</span>
            <span>${mon.stats.hp}</span>
          </div>
        </div>
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>攻擊力：</span>
            <span>${mon.stats.attack}</span>
          </div>
        </div>
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>護盾值：</span>
            <span>${mon.stats.shield}</span>
          </div>
        </div>
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>命中率：</span>
            <span>${Math.round(mon.stats.accuracy * 100)}%</span>
          </div>
        </div>
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>迴避率：</span>
            <span>${Math.round(mon.stats.evade * 100)}%</span>
          </div>
        </div>
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>攻擊速度：</span>
            <span>${mon.stats.atk_speed}</span>
          </div>
        </div>
        <div class="monster-stat-container">
          <div class="monster-stat-item">
            <span>護盾穿透：</span>
            <span>${monsterPenetrate}</span>
          </div>
        </div>
      </div>
    </div>
  `;
  
  return html;
}

// 載入副本資料
async function loadDungeonData() {
  try {
    const response = await fetch("parameter/dungeons.json");
    dungeonData = await response.json();
    return dungeonData;
  } catch (error) {
    console.error("載入副本資料失敗:", error);
    throw error;
  }
}

// 載入使用者狀態
async function loadUserStatus() {
  try {
    const response = await SecureAPI.get(`${API_BASE}/status`);
    userStatus = await response.json();
    return userStatus;
  } catch (error) {
    console.error("載入使用者狀態失敗:", error);
    throw error;
  }
}

// 載入怪物資料
async function loadMonster(monsterId) {
  try {
    const response = await SecureAPI.get(`${API_BASE}/monster?id=${monsterId}`);
    currentMonster = await response.json();
    return currentMonster;
  } catch (error) {
    console.error("載入怪物資料失敗:", error);
    throw error;
  }
}

// 戰鬥函數
async function startBattle() {
  if (!currentMonster || !userStatus) {
    alert("戰鬥資料載入中，請稍候");
    return;
  }

  const isLastLayer = parseInt(currentLayer) === dungeonData.find(d => d.id === currentDungeon).monsters.length;
  
  showBattleLoading(true, isLastLayer);
  
  // 模擬戰鬥載入過程
  await new Promise(resolve => {
    let progress = 0;
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");
    
    const interval = setInterval(() => {
      progress += Math.random() * 15 + 5;
      if (progress > 100) progress = 100;
      
      if (progressBar) progressBar.style.width = progress + "%";
      if (progressText) progressText.textContent = Math.round(progress) + "%";
      
      if (progress >= 100) {
        clearInterval(interval);
        resolve();
      }
    }, 100);
  });

  try {
    const response = await SecureAPI.post(`${API_BASE}/battle_dungeon`, {
      dungeon: currentDungeon,
      layer: parseInt(currentLayer)
    });
    
    const result = await response.json();
    
    showBattleLoading(false);
    
    if (response.ok) {
      handleBattleResult(result);
    } else {
      alert(result.error || "戰鬥失敗");
    }
  } catch (error) {
    showBattleLoading(false);
    console.error("戰鬥錯誤:", error);
    alert("戰鬥過程發生錯誤");
  }
}

// 處理戰鬥結果
function handleBattleResult(result) {
  const logArea = document.getElementById("logArea");
  if (logArea && result.battle_log) {
    // 修復：正確處理戰鬥紀錄，避免 [object object] 顯示
    if (Array.isArray(result.battle_log)) {
      logArea.textContent = result.battle_log.join('\n');
    } else if (typeof result.battle_log === 'string') {
      logArea.textContent = result.battle_log;
    } else {
      logArea.textContent = JSON.stringify(result.battle_log, null, 2);
    }
  }

  const battleBtn = document.getElementById("battleBtn");
  const retryBtn = document.getElementById("retryBtn");
  const nextBtn = document.getElementById("nextBtn");
  const leaveBtn = document.getElementById("leaveBtn");

  if (result.success) {
    // 修復：只有BOSS關卡勝利才顯示勝利特效
    if (result.is_last_layer) {
      showVictoryEffect();
    }
    
    if (battleBtn) battleBtn.style.display = "none";
    if (retryBtn) retryBtn.style.display = "none";
    
    if (result.is_last_layer) {
      // BOSS關卡完成
      if (nextBtn) {
        nextBtn.textContent = "返回副本列表";
        nextBtn.onclick = () => window.parent.loadPage("dungeons.html");
        nextBtn.style.display = "inline-block";
      }
    } else {
      // 普通關卡完成，可進入下一層
      if (nextBtn) {
        nextBtn.textContent = "下一層";
        nextBtn.onclick = () => {
          const nextLayer = parseInt(currentLayer) + 1;
          window.parent.loadPage(`dungeon_layer.html?dungeon=${currentDungeon}&layer=${nextLayer}`);
        };
        nextBtn.style.display = "inline-block";
      }
    }
    
    if (leaveBtn) leaveBtn.style.display = "inline-block";
    
    // 更新使用者狀態
    if (result.user) {
      userStatus = result.user;
      document.getElementById("userInfo").innerHTML = formatStats(userStatus);
      
      // 重新應用展開狀態
      setTimeout(() => {
        if (detailsExpanded) {
          const playerContainers = document.querySelectorAll('.stat-item-container');
          const playerDetails = document.querySelectorAll('.stat-detail');
          
          playerDetails.forEach((detail, index) => {
            if (detail.classList.contains('expanded') && playerContainers[index]) {
              playerContainers[index].classList.add('has-expanded');
            }
          });
        }
      }, 50);
    }
    
  } else {
    // 戰鬥失敗
    showDefeatEffect();
    
    if (battleBtn) battleBtn.style.display = "none";
    if (retryBtn) retryBtn.style.display = "inline-block";
    if (nextBtn) nextBtn.style.display = "none";
    if (leaveBtn) leaveBtn.style.display = "inline-block";
  }
}

// 重試戰鬥
function retryBattle() {
  const battleBtn = document.getElementById("battleBtn");
  const retryBtn = document.getElementById("retryBtn");
  const nextBtn = document.getElementById("nextBtn");
  const leaveBtn = document.getElementById("leaveBtn");
  
  if (battleBtn) battleBtn.style.display = "inline-block";
  if (retryBtn) retryBtn.style.display = "none";
  if (nextBtn) nextBtn.style.display = "none";
  if (leaveBtn) leaveBtn.style.display = "none";
  
  // 清空戰鬥記錄
  const logArea = document.getElementById("logArea");
  if (logArea) logArea.textContent = "";
}

// 離開副本
function leaveDungeon() {
  window.parent.loadPage("dungeons.html");
}

// 特效函數
function showVictoryEffect() {
  const overlay = document.getElementById("victoryOverlay");
  if (overlay) {
    overlay.style.display = "flex";
    createFireworks();
  }
}

function hideVictoryEffect() {
  const overlay = document.getElementById("victoryOverlay");
  if (overlay) overlay.style.display = "none";
}

function showDefeatEffect() {
  const overlay = document.getElementById("defeatOverlay");
  if (overlay) {
    overlay.style.display = "flex";
    createDebris();
  }
}

function hideDefeatEffect() {
  const overlay = document.getElementById("defeatOverlay");
  if (overlay) overlay.style.display = "none";
}

// 煙火效果
function createFireworks() {
  const container = document.getElementById("fireworksContainer");
  if (!container) return;
  
  container.innerHTML = "";
  
  for (let i = 0; i < 10; i++) {
    setTimeout(() => {
      const firework = document.createElement("div");
      firework.className = "firework";
      firework.style.left = Math.random() * 100 + "%";
      firework.style.top = Math.random() * 100 + "%";
      container.appendChild(firework);
      
      setTimeout(() => {
        if (firework.parentNode) {
          firework.parentNode.removeChild(firework);
        }
      }, 2000);
    }, i * 200);
  }
}

// 碎片效果
function createDebris() {
  const container = document.getElementById("debrisContainer");
  if (!container) return;
  
  container.innerHTML = "";
  
  for (let i = 0; i < 15; i++) {
    const debris = document.createElement("div");
    debris.className = "debris-piece";
    debris.style.left = Math.random() * 100 + "%";
    debris.style.animationDelay = Math.random() * 2 + "s";
    container.appendChild(debris);
  }
}

// 設定全域函數
window.startBattle = startBattle;
window.retryBattle = retryBattle;
window.leaveDungeon = leaveDungeon;
window.hideVictoryEffect = hideVictoryEffect;
window.hideDefeatEffect = hideDefeatEffect;

// 初始化
async function initDungeonLayer() {
  showLoading(true);
  
  try {
    const params = getURLParams();
    currentDungeon = params.dungeon;
    currentLayer = params.layer;
    
    if (!currentDungeon || currentLayer === null) {
      throw new Error("缺少副本參數");
    }
    
    // 並行載入資料
    await Promise.all([
      loadDungeonData(),
      loadUserStatus()
    ]);
    
    // 找到對應的副本
    const dungeon = dungeonData.find(d => d.id === currentDungeon);
    if (!dungeon) {
      throw new Error("找不到指定副本");
    }
    
    // 確定怪物ID
    const layerIndex = parseInt(currentLayer);
    const isLastLayer = layerIndex === dungeon.monsters.length;
    const monsterId = isLastLayer ? dungeon.bossId : dungeon.monsters[layerIndex];
    
    if (!monsterId) {
      throw new Error("找不到對應層數的怪物");
    }
    
    // 載入怪物資料
    await loadMonster(monsterId);
    
    // 設定BOSS模式
    if (isLastLayer) {
      document.body.classList.add("boss-mode");
      
      // 通知父框架切換音樂
      window.parent.postMessage({
        command: "switchToBossMusic"
      }, "*");
    }
    
    // 渲染介面
    document.getElementById("userInfo").innerHTML = formatStats(userStatus);
    document.getElementById("monsterInfo").innerHTML = formatMonsterInfo(currentMonster, isLastLayer);
    
    // 確保正確應用展開狀態
    setTimeout(() => {
      const playerContainers = document.querySelectorAll('.stat-item-container');
      const playerDetails = document.querySelectorAll('.stat-detail');
      
      playerDetails.forEach((detail, index) => {
        if (detail.classList.contains('expanded') && playerContainers[index]) {
          playerContainers[index].classList.add('has-expanded');
        }
      });
      
      const monsterDetail = document.querySelector('.monster-element-detail');
      const monsterContainer = monsterDetail?.closest('.monster-stat-container');
      
      if (monsterDetail?.classList.contains('expanded') && monsterContainer) {
        monsterContainer.classList.add('has-expanded');
      }
    }, 50);
    
  } catch (error) {
    console.error("初始化失敗:", error);
    alert("載入副本失敗：" + error.message);
    window.parent.loadPage("dungeons.html");
  } finally {
    showLoading(false);
  }
}

// 監聽登入狀態
onAuthStateChanged(auth, (user) => {
  if (user) {
    initDungeonLayer();
  } else {
    window.parent.location.href = "/SFL/login.html";
  }
});

// 頁面載入粒子效果
function createPageParticles() {
  const particlesContainer = document.getElementById("pageParticles");
  if (!particlesContainer) return;
  particlesContainer.innerHTML = "";
  for (let i = 0; i < 30; i++) {
    const particle = document.createElement("div");
    particle.className = "particle";
    particle.style.left = Math.random() * 100 + "%";
    particle.style.animationDelay = Math.random() * 4 + "s";
    particle.style.animationDuration = (Math.random() * 2 + 3) + "s";
    particle.style.background = `rgba(${Math.random() > 0.5 ? '56, 239, 125' : '17, 153, 142'}, 0.7)`;
    particlesContainer.appendChild(particle);
  }
}

function startPageLoadingProgress() {
  const progressBar = document.getElementById("pageProgressBar");
  const progressText = document.getElementById("pageProgressText");
  const loadingText = document.getElementById("pageLoadingText");
  if (!progressBar || !progressText || !loadingText) return;

  const messages = [
    "正在載入副本資料...",
    "獲取玩家狀態...",
    "載入怪物資訊...",
    "準備戰鬥環境...",
    "載入完成！"
  ];

  let progress = 0;
  let messageIndex = 0;
  const progressInterval = setInterval(() => {
    progress += Math.random() * 20 + 10;
    if (progress > 100) progress = 100;

    progressBar.style.width = progress + "%";
    progressText.textContent = Math.round(progress) + "%";

    if (messageIndex < messages.length - 1 && progress > (messageIndex + 1) * 20) {
      messageIndex++;
      loadingText.textContent = messages[messageIndex];
    }

    if (progress >= 100) {
      clearInterval(progressInterval);
      loadingText.textContent = messages[messages.length - 1];
    }
  }, 300);

  window.pageLoadingInterval = progressInterval;
}

createPageParticles();
startPageLoadingProgress();
</script>
</body>
</html>
