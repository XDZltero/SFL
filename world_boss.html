<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<title>世界王挑戰</title>
<link rel="icon" href="favicon.ico" />
<link href="css/style.css" rel="stylesheet"/>
<link href="css/dungeon_layer_winning.css" rel="stylesheet"/>
<link href="css/dungeon_layer.css" rel="stylesheet"/>
<link href="css/world_boss.css" rel="stylesheet"/>
</head>
<body class="world-boss-mode">

<!-- 世界王血量條 -->
<div class="world-boss-hp-container">
  <div class="world-boss-title">🌍 世界王挑戰 🌍</div>
  <div class="world-hp-bar-container">
    <div class="world-hp-bar" id="worldHpBar" style="width: 100%;">
      <div class="world-hp-text" id="worldHpText">載入中...</div>
    </div>
  </div>
  <div class="world-boss-stats">
    <div class="world-stat-item">攻擊次數: <span class="world-stat-value" id="totalAttacks">-</span></div>
    <div class="world-stat-item">參與玩家: <span class="world-stat-value" id="uniquePlayers">-</span></div>
    <div class="world-stat-item">等級: <span class="world-stat-value" id="bossLevel">80</span></div>
    <div class="world-stat-item">階段: <span class="world-stat-value" id="currentPhase">1 / 3</span></div>
  </div>
</div>

<!-- 階段指示器 -->
<div class="phase-indicator" id="phaseIndicator">
  載入階段資訊...
</div>

<!-- 倒數計時器 -->
<div class="countdown-timer">
  <div class="countdown-label">⏰ 挑戰開放倒數</div>
  <div class="countdown-value" id="countdownDisplay">計算中...</div>
</div>

<!-- 頁面載入遮罩 -->
<div id="loadingOverlay">
  <div class="particles" id="pageParticles"></div>
  <div class="battle-loading-container">
    <div class="battle-icon">🐲</div>
    <div class="battle-title normal-title">載入世界王</div>
    <div class="loading-text" id="pageLoadingText">正在連接世界王戰場...</div>
    <div class="progress-container">
      <div class="progress-bar" id="pageProgressBar"></div>
    </div>
    <div class="progress-text" id="pageProgressText">0%</div>
    <div class="battle-tips">
      🌍 全世界的冒險者正在一起戰鬥！<br/>
      ⚔️ 每一次攻擊都關乎人類的命運
    </div>
  </div>
</div>

<!-- 主要內容區域 -->
<div class="world-boss-container">
  <!-- 左側面板：玩家挑戰區域 -->
  <div class="left-panel">
    <!-- 時間限制提示（週日顯示） -->
    <div class="time-restriction-notice" id="timeRestriction" style="display: none;">
      <div class="restriction-title">⏰ 挑戰時間限制</div>
      <div class="restriction-message">
        世界王每週日進行休整，無法挑戰<br>
        挑戰將於下週一 00:00 重新開放
      </div>
    </div>

    <!-- 玩家挑戰卡片 -->
    <div class="player-challenge-card">

      <div class="player-level-info" style="text-align: center; margin-bottom: 15px; padding: 10px; background: rgba(0,255,255,0.1); border-radius: 8px;">
        <div style="color: #ffd93d; font-size: 1.1em; font-weight: 600;">
          ⭐ 你的等級：<span id="playerLevel">載入中...</span>
        </div>
        <div style="color: #00ffff; font-size: 0.9em; margin-top: 5px;">
          世界王挑戰需求：30 等以上
        </div>
      </div>
    
      <!-- 🚀 新增：等級不足提示（預設隱藏） -->
      <div class="level-requirement-notice" id="levelRequirementNotice" style="display: none;">
        <div class="restriction-title">⚡ 等級限制</div>
        <div class="restriction-message">
          需要達到 <strong>30 等</strong> 才能挑戰世界王<br>
          你目前是 <span id="currentLevelDisplay">-</span> 等，還需要 <span id="levelShortage">-</span> 等
        </div>
      </div>
      
      <div class="player-damage-stats">
        <div class="damage-title">🏆 你的累積傷害</div>
        <div class="total-damage" id="playerTotalDamage">0</div>
        <div class="damage-rank" id="playerRank">排名: 未參與</div>
        <div style="margin-top: 10px; font-size: 0.9em; color: #ccc;">
          挑戰次數: <span id="challengeCount">0</span> 次
        </div>
      </div>
      
      <div class="challenge-button-area">
        <button class="world-challenge-btn" id="challengeBtn" onclick="challengeWorldBoss()">
          🌍 挑戰世界王 🌍
        </button>
        <div class="cooldown-info" id="cooldownInfo" style="display: none;">
          冷卻中，請等待：<span id="cooldownTimer">00:00</span>
        </div>
      </div>
    </div>
  </div>

  <!-- 世界王資訊 -->
    <div class="section world-boss-info-container">
      <div class="world-boss-name" id="bossName">載入中...</div>
      <div class="world-boss-phase" id="phaseDescription">載入階段資訊...</div>
      <img src="" class="world-boss-image" id="bossImage" width="250">
      <div class="world-boss-description" id="bossDescription">載入中...</div>
    </div>

  <!-- 右側面板：排行榜 -->
  <div class="right-panel">
    <div class="leaderboard-card">
      <div class="leaderboard-title">🏆 傷害排行榜</div>
      <div class="leaderboard-list" id="leaderboardList">
        <div style="text-align: center; color: #888; padding: 20px;">
          載入排行榜中...
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 勝利/戰鬥結果遮罩 -->
<div class="victory-overlay" id="battleResultOverlay" style="display: none;">
  <div class="victory-content">
    <div class="victory-icon" id="battleResultIcon">⚔️</div>
    <div class="victory-title" id="battleResultTitle">戰鬥結果</div>
    <div class="victory-message" id="battleResultMessage">結果訊息</div>
    <button class="effect-button" onclick="closeBattleResult()">確定</button>
  </div>
</div>

<script type="module">
import { auth, SecureAPI, PerformanceMonitor } from "./js/firebase-init.js";
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

const API_BASE = "https://sfl-9cb8.onrender.com";

let worldBossData = null;
let playerData = null;
let leaderboardData = [];
let cooldownTimer = null;
let currentUserNickname = "";
let userLevel = 0;
const REQUIRED_LEVEL = 30;
  
// 階段配置
const PHASES = {
  1: {
    name: "【第一階段】資料載入中",
    description: "資料載入中...",
    hp_threshold: 100
  },
  2: {
    name: "【第二階段】資料載入中",
    description: "資料載入中...",
    hp_threshold: 60
  },
  3: {
    name: "【第三階段】資料載入中",
    description: "資料載入中...",
    hp_threshold: 30
  }
};

// 載入頁面初始化
function createPageParticles() {
  const particlesContainer = document.getElementById("pageParticles");
  if (!particlesContainer) return;
  particlesContainer.innerHTML = "";
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement("div");
    particle.className = "particle";
    particle.style.left = Math.random() * 100 + "%";
    particle.style.animationDelay = Math.random() * 4 + "s";
    particle.style.animationDuration = (Math.random() * 2 + 3) + "s";
    particle.style.background = `rgba(${Math.random() > 0.5 ? '255, 215, 0' : '255, 140, 0'}, 0.8)`;
    particlesContainer.appendChild(particle);
  }
}

// 載入使用者等級資訊
async function loadUserLevel() {
  try {
    const statusRes = await SecureAPI.getStatus(false);
    const userData = await statusRes.json();
    
    userLevel = userData.level || 1;
    currentUserNickname = userData.nickname || userData.user_id;
    
    // 更新等級顯示
    document.getElementById("playerLevel").textContent = userLevel;
    
    // 檢查等級限制
    checkLevelRequirement();
    
    console.log(`✅ 使用者等級載入：${userLevel}`);
    
  } catch (error) {
    console.error('載入使用者等級失敗:', error);
    document.getElementById("playerLevel").textContent = "載入失敗";
  }
}

function checkLevelRequirement() {
  const challengeBtnEl = document.getElementById("challengeBtn");
  const levelNoticeEl = document.getElementById("levelRequirementNotice");
  const currentLevelEl = document.getElementById("currentLevelDisplay");
  const levelShortageEl = document.getElementById("levelShortage");
  
  if (userLevel < REQUIRED_LEVEL) {
    // 等級不足
    if (levelNoticeEl) levelNoticeEl.style.display = "block";
    if (currentLevelEl) currentLevelEl.textContent = userLevel;
    if (levelShortageEl) levelShortageEl.textContent = REQUIRED_LEVEL - userLevel;
    
    if (challengeBtnEl) {
      challengeBtnEl.disabled = true;
      challengeBtnEl.textContent = `⚡ 需要 ${REQUIRED_LEVEL} 等`;
      challengeBtnEl.dataset.levelLocked = "true";
      
      // 設定特殊樣式
      challengeBtnEl.style.background = "linear-gradient(135deg, #6c757d 0%, #495057 100%)";
      challengeBtnEl.style.color = "#adb5bd";
      challengeBtnEl.style.cursor = "not-allowed";
    }
    
  } else {
    // 等級足夠
    if (levelNoticeEl) levelNoticeEl.style.display = "none";
    if (challengeBtnEl) challengeBtnEl.dataset.levelLocked = "false";
    
    // 恢復正常樣式（如果沒有其他限制）
    if (!isWeekend() && challengeBtnEl && !challengeBtnEl.dataset.cooling) {
      challengeBtnEl.disabled = false;
      challengeBtnEl.textContent = "🌍 挑戰世界王 🌍";
      challengeBtnEl.style.background = "";
      challengeBtnEl.style.color = "";
      challengeBtnEl.style.cursor = "";
    }
  }
}

function handleWorldBossError(error, context = "未知操作") {
  console.error(`世界王${context}失敗:`, error);
  
  // 根據錯誤類型提供不同的恢復建議
  if (error.message.includes('fetch') || error.message.includes('network')) {
    showBattleResult(false, "網路錯誤", 
      "連線中斷，請檢查網路連線後重試\n\n如果問題持續發生，請重新整理頁面");
    
    // 自動重試機制
    setTimeout(() => {
      if (confirm("是否自動重新載入世界王資料？")) {
        loadWorldBossData();
      }
    }, 3000);
    
  } else if (error.message.includes('token') || error.message.includes('auth')) {
    showBattleResult(false, "認證錯誤", 
      "登入狀態已過期，請重新登入");
    
    setTimeout(() => {
      window.parent.location.href = "/SFL/login.html";
    }, 2000);
    
  } else {
    showBattleResult(false, "系統錯誤", 
      `${context}時發生錯誤，請稍後再試\n\n錯誤訊息：${error.message}`);
  }
}
  
function startPageLoadingProgress() {
  const progressBar = document.getElementById("pageProgressBar");
  const progressText = document.getElementById("pageProgressText");
  const loadingText = document.getElementById("pageLoadingText");
  if (!progressBar || !progressText || !loadingText) return;

  const messages = [
    "正在連接世界王戰場...",
    "載入全球戰鬥資料...", 
    "同步世界王狀態...",
    "載入排行榜資料...",
    "連接完成！"
  ];

  let progress = 0;
  let messageIndex = 0;
  const progressInterval = setInterval(() => {
    progress += Math.random() * 15 + 10;
    if (progress > 100) progress = 100;

    progressBar.style.width = progress + "%";
    progressText.textContent = Math.round(progress) + "%";

    if (messageIndex < messages.length - 1 && progress > (messageIndex + 1) * 20) {
      messageIndex++;
      loadingText.textContent = messages[messageIndex];
    }

    if (progress >= 100) {
      clearInterval(progressInterval);
      loadingText.textContent = messages[messages.length - 1];
    }
  }, 300);

  window.pageLoadingInterval = progressInterval;
}

function showLoading(show) {
  const loading = document.getElementById("loadingOverlay");
  if (!loading) return;
  loading.style.display = show ? "flex" : "none";
}

function hidePageLoading() {
  if (window.pageLoadingInterval) {
    clearInterval(window.pageLoadingInterval);
  }
  setTimeout(() => {
    showLoading(false);
  }, 1000);
}

// 時間相關函數
function isWeekend() {
  const now = new Date();
  const taipeiTime = new Date(now.toLocaleString("en-US", {timeZone: "Asia/Taipei"}));
  return taipeiTime.getDay() === 0; // 週日
}

function getNextMondayCountdown() {
  const now = new Date();
  const taipeiTime = new Date(now.toLocaleString("en-US", {timeZone: "Asia/Taipei"}));
  
  // 找下週一 00:00
  const nextMonday = new Date(taipeiTime);
  const daysUntilMonday = (7 - taipeiTime.getDay() + 1) % 7;
  nextMonday.setDate(taipeiTime.getDate() + (daysUntilMonday === 0 ? 7 : daysUntilMonday));
  nextMonday.setHours(0, 0, 0, 0);
  
  const diff = nextMonday - taipeiTime;
  
  if (diff <= 0) return "00:00:00";
  
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// 倒數計時器
function updateCountdown() {
  const countdownEl = document.getElementById("countdownDisplay");
  const timeRestrictionEl = document.getElementById("timeRestriction");
  const challengeBtnEl = document.getElementById("challengeBtn");
  
  if (isWeekend()) {
    countdownEl.textContent = getNextMondayCountdown();
    timeRestrictionEl.style.display = "block";
    if (!challengeBtnEl.dataset.levelLocked || challengeBtnEl.dataset.levelLocked === "false") {
      challengeBtnEl.disabled = true;
      challengeBtnEl.textContent = "⏰ 週日休整中";
    }
  } else {
    timeRestrictionEl.style.display = "none";
    countdownEl.textContent = "挑戰開放中";
    
    // 🚀 新增：重新檢查等級限制
    checkLevelRequirement();
  }
}

// 更新冷卻時間顯示
function updateCooldownDisplay(cooldownEndTime) {
  const cooldownInfoEl = document.getElementById("cooldownInfo");
  const cooldownTimerEl = document.getElementById("cooldownTimer");
  const challengeBtnEl = document.getElementById("challengeBtn");
  
  if (!cooldownEndTime) {
    cooldownInfoEl.style.display = "none";
    challengeBtnEl.dataset.cooling = "false";
    
    // 🚀 新增：檢查等級限制
    if (userLevel < REQUIRED_LEVEL) {
      checkLevelRequirement();
    } else if (!isWeekend()) {
      challengeBtnEl.disabled = false;
      challengeBtnEl.textContent = "🌍 挑戰世界王 🌍";
    }
    return;
  }
  
  const now = Date.now();
  const remaining = cooldownEndTime - now;
  
  if (remaining <= 0) {
    cooldownInfoEl.style.display = "none";
    challengeBtnEl.dataset.cooling = "false";
    
    // 🚀 新增：檢查等級限制
    if (userLevel < REQUIRED_LEVEL) {
      checkLevelRequirement();
    } else if (!isWeekend()) {
      challengeBtnEl.disabled = false;
      challengeBtnEl.textContent = "🌍 挑戰世界王 🌍";
    }
    
    if (cooldownTimer) {
      clearInterval(cooldownTimer);
      cooldownTimer = null;
    }
    return;
  }
  
  const minutes = Math.floor(remaining / (1000 * 60));
  const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
  
  cooldownInfoEl.style.display = "block";
  cooldownTimerEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  challengeBtnEl.disabled = true;
  challengeBtnEl.dataset.cooling = "true";
  challengeBtnEl.textContent = "⏰ 冷卻中";
}

// 階段系統
function getCurrentPhase(currentHp, maxHp) {
  const percentage = (currentHp / maxHp) * 100;
  
  // 使用 API 資料中的 hp_threshold
  if (worldBossData?.phases) {
    const phases = worldBossData.phases;
    
    // 從最低階段開始檢查
    if (percentage <= (phases["3"]?.hp_threshold || 30)) return 3;
    if (percentage <= (phases["2"]?.hp_threshold || 60)) return 2;
    return 1;
  }
  
  // 降級處理：使用硬編碼值
  if (percentage > 60) return 1;
  if (percentage > 30) return 2;
  return 3;
}

function updatePhaseDisplay(phase) {
  const phaseIndicatorEl = document.getElementById("phaseIndicator");
  const phaseDescriptionEl = document.getElementById("phaseDescription");
  const currentPhaseEl = document.getElementById("currentPhase");
  
  const phaseInfo = worldBossData?.phases?.[phase.toString()];
  if (phaseInfo) {
    phaseIndicatorEl.textContent = phaseInfo.name;
    phaseDescriptionEl.textContent = phaseInfo.description;
    currentPhaseEl.textContent = `${phase} / 3`;
  } else {
    phaseIndicatorEl.textContent = `【第${phase}階段】`;
    phaseDescriptionEl.textContent = "階段資料載入中...";
    currentPhaseEl.textContent = `${phase} / 3`;
  }
}

// 更新世界王血量和階段
function updateWorldBossHP(current, max) {
  const hpBar = document.getElementById("worldHpBar");
  const hpText = document.getElementById("worldHpText");
  
  const percentage = Math.max(0, (current / max) * 100);
  hpBar.style.width = percentage + "%";
  hpText.textContent = `${current.toLocaleString()} / ${max.toLocaleString()} (${percentage.toFixed(1)}%)`;
  
  // 更新階段
  const currentPhase = getCurrentPhase(current, max);
  updatePhaseDisplay(currentPhase);
}

// 更新玩家傷害顯示
function updatePlayerDamage(damage, rank, challengeCount = 0) {
  const damageEl = document.getElementById("playerTotalDamage");
  const rankEl = document.getElementById("playerRank");
  const countEl = document.getElementById("challengeCount");
  
  damageEl.textContent = damage.toLocaleString();
  rankEl.textContent = rank > 0 ? `排名: #${rank}` : "排名: 未參與";
  countEl.textContent = challengeCount;
}

// 更新排行榜
function updateLeaderboard(leaderboard) {
  const listEl = document.getElementById("leaderboardList");
  
  if (!leaderboard || leaderboard.length === 0) {
    listEl.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">暫無排行榜資料</div>';
    return;
  }
  
  // 🎯 限制只顯示前10名
  const top10 = leaderboard.slice(0, 10);
  
  let html = '';
  top10.forEach((player, index) => {
    const rank = index + 1;
    const isCurrentPlayer = player.nickname === currentUserNickname;
    const isTop3 = rank <= 3;
    
    let rankClass = '';
    if (rank === 1) rankClass = 'top-1';
    else if (rank === 2) rankClass = 'top-2';
    else if (rank === 3) rankClass = 'top-3';
    
    let itemClass = 'leaderboard-item';
    if (isTop3) itemClass += ' top-3';
    if (isCurrentPlayer) itemClass += ' current-player';
    
    html += `
      <div class="${itemClass}">
        <div class="rank-number ${rankClass}">#${rank}</div>
        <div class="player-name">${player.nickname}${isCurrentPlayer ? ' (你)' : ''}</div>
        <div class="damage-amount">${player.total_damage.toLocaleString()}</div>
      </div>
    `;
  });
  
  // 🎯 如果當前玩家不在前10名，額外顯示自己的排名
  if (currentUserNickname) {
    const currentPlayerInTop10 = top10.find(p => p.nickname === currentUserNickname);
    
    if (!currentPlayerInTop10 && playerData && playerData.rank > 10) {
      // 找到當前玩家在完整排行榜中的資料
      const currentPlayerData = leaderboard.find(p => p.nickname === currentUserNickname);
      
      if (currentPlayerData) {
        html += `
          <div class="leaderboard-divider" style="margin: 15px 0; border-top: 1px solid rgba(255,215,0,0.3); text-align: center; padding-top: 10px;">
            <span style="color: #ffd700; font-size: 0.9em;">--- 你的排名 ---</span>
          </div>
          <div class="leaderboard-item current-player">
            <div class="rank-number">#${playerData.rank}</div>
            <div class="player-name">${currentPlayerData.nickname} (你)</div>
            <div class="damage-amount">${currentPlayerData.total_damage.toLocaleString()}</div>
          </div>
        `;
      }
    }
  }
  
  // 🎯 添加顯示說明
  if (leaderboard.length > 10) {
    html += `
      <div style="text-align: center; color: #888; padding: 15px 10px; font-size: 0.85em; border-top: 1px solid rgba(255,255,255,0.1); margin-top: 10px;">
        顯示前 10 名 / 共 ${leaderboard.length} 名參與者
      </div>
    `;
  }
  
  listEl.innerHTML = html;
}

// 載入世界王資料
async function loadWorldBossData() {
  try {
    PerformanceMonitor.startTiming('loadWorldBoss');
    
    // 🚀 先檢查世界王是否已初始化
    try {
      const initCheckRes = await SecureAPI.get(`${API_BASE}/world_boss_init_check`);
      const initResult = await initCheckRes.json();
      if (!initResult.initialized) {
        console.warn('世界王未初始化:', initResult.error);
        showBattleResult(false, "系統錯誤", "世界王系統尚未初始化，請聯繫管理員");
        return;
      }
    } catch (initError) {
      console.warn('世界王初始化檢查失敗:', initError);
    }
    
    // 🚀 優化：並行載入但有超時保護
    const timeout = 10000; // 10秒超時
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('請求超時')), timeout)
    );
    
    const [bossRes, leaderboardRes, playerRes] = await Promise.race([
      Promise.all([
        SecureAPI.get(`${API_BASE}/world_boss_status`),
        SecureAPI.get(`${API_BASE}/world_boss_leaderboard?limit=50`),
        SecureAPI.get(`${API_BASE}/world_boss_player_data`)
      ]),
      timeoutPromise
    ]);
    
    // 處理世界王狀態
    if (bossRes.ok) {
      worldBossData = await bossRes.json();
      if (worldBossData.phases) {
        console.log('✅ 階段資料載入成功:', Object.keys(worldBossData.phases));
      } else {
        console.warn('⚠️ 階段資料載入失敗');
      }
      
      updateWorldBossInfo(worldBossData);
      updateWorldBossStats(worldBossData);
      
      console.log(`📊 世界王統計 - 總攻擊: ${worldBossData.total_participants}, 獨特玩家: ${worldBossData.unique_players}`);
    } else {
      throw new Error(`載入世界王狀態失敗: ${bossRes.status}`);
    }
    
    // 處理排行榜
    if (leaderboardRes.ok) {
      const leaderboardResult = await leaderboardRes.json();
      updateLeaderboard(leaderboardResult.leaderboard || []);
    } else {
      console.warn('載入排行榜失敗:', leaderboardRes.status);
      updateLeaderboard([]);
    }
    
    // 處理玩家資料
    if (playerRes.ok) {
      playerData = await playerRes.json();
      updatePlayerDamage(playerData.total_damage, playerData.rank, playerData.challenge_count);
      
      // 如果有冷卻時間，開始倒數
      if (playerData.cooldown_end_time) {
        startCooldownTimer(playerData.cooldown_end_time);
      }
    } else {
      console.warn('載入玩家數據失敗:', playerRes.status);
      updatePlayerDamage(0, 0, 0);
    }
    
    console.log('✅ 世界王資料載入完成');
    
  } catch (error) {
    console.error('載入世界王資料失敗:', error);
    
    // 🚀 改進的錯誤處理
    if (error.message.includes('超時')) {
      showBattleResult(false, "連線超時", "載入世界王資料超時，請檢查網路連線並重新整理頁面");
    } else if (error.message.includes('fetch')) {
      showBattleResult(false, "網路錯誤", "無法連接到伺服器，請檢查網路連線");
    } else {
      showBattleResult(false, "載入錯誤", "載入世界王資料時發生錯誤，請重新整理頁面");
    }
    
    // 設置錯誤狀態的顯示
    document.getElementById("bossName").textContent = "載入失敗";
    document.getElementById("leaderboardList").innerHTML = 
      '<div style="text-align: center; color: #ff6b6b; padding: 20px;">載入失敗，請重新整理頁面</div>';
    
  } finally {
    PerformanceMonitor.endTiming('loadWorldBoss');
  }
}


function updateWorldBossInfo(boss) {
  document.getElementById("bossName").innerHTML = boss.name.replace(/\n/g, "<br>");
  document.getElementById("bossImage").src = boss.image;
  document.getElementById("bossDescription").textContent = boss.description;
  document.getElementById("bossLevel").textContent = boss.level;
  
  // 🚀 統一使用新的統計更新函數
  updateGlobalStats(boss);
  
  updateWorldBossHP(boss.current_hp, boss.max_hp);
  
  const currentPhase = getCurrentPhase(boss.current_hp, boss.max_hp);
  updatePhaseDisplay(currentPhase);
}

function updateWorldBossStats(boss) {
  // 更新主要統計資訊
  document.getElementById("totalAttacks").textContent = (boss.total_participants || 0).toLocaleString();
  document.getElementById("bossLevel").textContent = boss.level;
  document.getElementById("currentPhase").textContent = `${boss.current_phase || 1} / 3`;
  
  // 顯示詳細統計資訊
  const statsContainer = document.querySelector('.world-boss-stats');
  if (statsContainer && boss.unique_players !== undefined) {
    // 清除現有統計並重新建立
    statsContainer.innerHTML = `
      <div class="world-stat-item">總攻擊次數: <span class="world-stat-value" id="totalAttacks">${(boss.total_participants || 0).toLocaleString()}</span></div>
      <div class="world-stat-item">參與玩家: <span class="world-stat-value" id="uniquePlayers">${(boss.unique_players || 0).toLocaleString()}</span></div>
      <div class="world-stat-item">等級: <span class="world-stat-value" id="bossLevel">${boss.level}</span></div>
      <div class="world-stat-item">階段: <span class="world-stat-value" id="currentPhase">${boss.current_phase || 1} / 3</span></div>
    `;
  }
}

// 開始冷卻計時器
function startCooldownTimer(endTime) {
  if (cooldownTimer) {
    clearInterval(cooldownTimer);
  }
  
  cooldownTimer = setInterval(() => {
    updateCooldownDisplay(endTime);
  }, 1000);
  
  updateCooldownDisplay(endTime);
}

// 顯示戰鬥結果
function showBattleResult(success, title, message, damage = 0) {
  const overlay = document.getElementById("battleResultOverlay");
  const icon = document.getElementById("battleResultIcon");
  const titleEl = document.getElementById("battleResultTitle");
  const messageEl = document.getElementById("battleResultMessage");
  
  if (success) {
    if (title.includes("完美攻擊")) {
      overlay.style.background = "linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 165, 0, 0.9), rgba(255, 140, 0, 0.95))";
    } else if (title.includes("強力攻擊")) {
      overlay.style.background = "linear-gradient(135deg, rgba(138, 43, 226, 0.9), rgba(75, 0, 130, 0.85), rgba(148, 0, 211, 0.9))";
    } else if (title.includes("有效攻擊")) {
      overlay.style.background = "linear-gradient(135deg, rgba(0, 100, 255, 0.9), rgba(0, 150, 255, 0.85), rgba(30, 144, 255, 0.9))";
    } else {
      overlay.style.background = "linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 140, 0, 0.8), rgba(255, 69, 0, 0.9))";
    }
    
    // 🔧 修正：使用 Array.from() 正確處理 Unicode 字符
    const titleChars = Array.from(title);
    icon.textContent = titleChars[0]; // 這樣能正確取得完整的 emoji
    
    titleEl.textContent = title;
    messageEl.innerHTML = message;
  } else {
    icon.textContent = "❌";
    titleEl.textContent = title || "挑戰失敗";
    messageEl.textContent = message || "挑戰過程發生錯誤";
    overlay.style.background = "linear-gradient(135deg, rgba(139, 0, 0, 0.9), rgba(220, 20, 60, 0.8), rgba(75, 0, 130, 0.9))";
  }
  
  overlay.style.display = "flex";
}

function closeBattleResult() {
  document.getElementById("battleResultOverlay").style.display = "none";
}

// 挑戰世界王
async function challengeWorldBoss() {
  // 前端等級檢查
  if (userLevel < REQUIRED_LEVEL) {
    showBattleResult(false, "等級不足", 
      `需要達到 ${REQUIRED_LEVEL} 等才能挑戰世界王\n你目前是 ${userLevel} 等，還需要 ${REQUIRED_LEVEL - userLevel} 等`);
    return;
  }
  
  if (isWeekend()) {
    showBattleResult(false, "時間限制", "世界王於週日休整，請於週一再來挑戰！");
    return;
  }
  
  const challengeBtnEl = document.getElementById("challengeBtn");
  if (challengeBtnEl.disabled) return;
  
  challengeBtnEl.disabled = true;
  challengeBtnEl.textContent = "⚔️ 戰鬥中...";
  
  try {
    const response = await SecureAPI.post(`${API_BASE}/world_boss_challenge`, {});
    const result = await response.json();
    
    if (response.ok && result.success) {
      const message = `
        <div style="text-align: left; line-height: 1.6;">
          <div style="margin-bottom: 15px;">
            <div style="font-size: 1.3em; color: #ffd700; margin-bottom: 8px;">
              ${result.reward_tier} - ${result.tier_description}
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
              造成傷害：<span style="color: #ff6b6b; font-weight: bold;">${result.damage_dealt.toLocaleString()}</span><br>
              傷害百分比：<span style="color: #00ffff; font-weight: bold;">${result.damage_percentage.toFixed(4)}%</span><br>
              獲得經驗：<span style="color: #ffd700; font-weight: bold;">+${result.exp_gained.toLocaleString()}</span>
            </div>
            <div style="background: rgba(0,255,255,0.1); padding: 8px; border-radius: 6px;">
              累積傷害：${result.total_damage.toLocaleString()}<br>
              當前排名：#${result.current_rank}<br>
              <span style="color: #ffd700;">🎯 這是你的第 ${playerData.challenge_count + 1} 次攻擊</span>
            </div>
          </div>
        </div>
      `;
      
      // 🚀 根據獎勵等級顯示不同的標題和圖示
      let title = "⚔️ 戰鬥成功！";
      
      switch(result.reward_tier) {
        case "S級傷害":
          title = "🌟 完美攻擊！";
          break;
        case "A級傷害":
          title = "💥 強力攻擊！";
          break;
        case "B級傷害":
          title = "⚔️ 有效攻擊！";
          break;
        case "C級傷害":
          title = "🛡️ 成功命中！";
          break;
      }
      
      showBattleResult(true, title, message, result.damage_dealt);
      
      // 🚀 優化：直接使用後端返回的資料更新顯示，避免額外API調用
      updatePlayerDamage(result.total_damage, result.current_rank, playerData.challenge_count + 1);
      
      // 🚀 優化：使用後端返回的世界王血量資料更新顯示
      if (result.world_boss_hp) {
        updateWorldBossHP(result.world_boss_hp.current, result.world_boss_hp.max);
      }
      
      // 🚀 批次更新：只在必要時才重新載入完整資料
      setTimeout(async () => {
        try {
          // 只重新載入排行榜，因為其他資料已經從戰鬥結果獲得
          const leaderboardRes = await SecureAPI.get(`${API_BASE}/world_boss_leaderboard?limit=50`);
          if (leaderboardRes.ok) {
            const leaderboardResult = await leaderboardRes.json();
            updateLeaderboard(leaderboardResult.leaderboard || []);
          }
        } catch (updateError) {
          console.warn('更新排行榜失敗:', updateError);
        }
      }, 500); // 減少延遲
      
      // 開始冷卻計時
      startCooldownTimer(result.cooldown_end_time);
      
    } else {
      // 處理等級不足錯誤
      if (result.required_level && result.current_level) {
        showBattleResult(false, "等級限制", 
          `需要達到 ${result.required_level} 等才能挑戰世界王\n你目前是 ${result.current_level} 等，還需要升 ${result.level_shortage} 等`);
      } else {
        showBattleResult(false, "挑戰失敗", result.error || "未知錯誤");
      }
      
      // 重新檢查等級限制狀態
      checkLevelRequirement();
    }
    
  } catch (error) {
    console.error('挑戰世界王失敗:', error);
    showBattleResult(false, "連線錯誤", "挑戰過程發生錯誤，請稍後再試");
    
    // 重新檢查等級限制狀態
    checkLevelRequirement();
  }
}


// 專門更新統計資訊的函數
function updateGlobalStats(bossData) {
  // 🎯 正確的後端資料 → 前端元素對應
  const dataMapping = {
    // 後端 API 欄位 → 前端 DOM 元素 ID
    'total_participants': 'totalAttacks',      // 總攻擊次數
    'unique_players': 'uniquePlayers',         // 獨特玩家數
    'level': 'bossLevel',                      // 世界王等級
    'current_phase': 'currentPhase'            // 當前階段
  };
  
  // 🚀 安全更新函數
  const updateElement = (elementId, value) => {
    const element = document.getElementById(elementId);
    if (element) {
      element.textContent = value;
      return true;
    } else {
      console.warn(`⚠️ 找不到元素: ${elementId}`);
      return false;
    }
  };
  
  // 📊 執行資料更新（按照正確的對應關係）
  updateElement('totalAttacks', (bossData.total_participants || 0).toLocaleString());
  updateElement('uniquePlayers', (bossData.unique_players || 0).toLocaleString());
  updateElement('bossLevel', bossData.level || 100);
  updateElement('currentPhase', `${bossData.current_phase || 1} / 3`);
  
  console.log(`📊 統計更新完成:`);
  console.log(`  - 總攻擊次數: ${(bossData.total_participants || 0).toLocaleString()}`);
  console.log(`  - 獨特玩家: ${(bossData.unique_players || 0).toLocaleString()}`);
  console.log(`  - 總傷害: ${(bossData.total_damage_dealt || 0).toLocaleString()}`);
}
  
// 離開世界王戰場
function leaveWorldBoss() {
  window.parent.postMessage({ command: "restoreMainMusic" }, "*");
  setTimeout(() => {
    window.parent.loadPage('main_page.html');
  }, 300);
}

// 🔧 管理員功能：重置世界王（開發/測試用）
async function resetWorldBoss() {
  if (!confirm('⚠️ 確定要重置世界王嗎？\n這將重置血量和所有統計數據！\n\n是否同時清除排行榜？\n點確定=清除排行榜，取消=保留排行榜')) {
    return;
  }
  
  const clearLeaderboard = confirm('是否清除排行榜？\n確定=清除，取消=保留');
  
  try {
    const response = await SecureAPI.post(`${API_BASE}/world_boss_reset`, {
      clear_leaderboard: clearLeaderboard
    });
    const result = await response.json();
    
    if (response.ok) {
      showBattleResult(true, "重置成功", `世界王已重置！\n${clearLeaderboard ? '排行榜已清除' : '排行榜已保留'}`);
      setTimeout(() => {
        loadWorldBossData();
      }, 2000);
    } else {
      showBattleResult(false, "重置失敗", result.error);
    }
  } catch (error) {
    showBattleResult(false, "重置錯誤", "重置過程發生錯誤：" + error.message);
  }
}

// 🔧 開發者模式檢測
const isDeveloper = window.location.hostname === 'localhost' || 
                   window.location.search.includes('debug=true') ||
                   window.location.search.includes('admin=true');

// 強制刷新功能（父視窗調用）
window.addEventListener('message', (event) => {
  if (event.data && event.data.command === 'forceRefresh') {
    console.log('收到強制刷新指令');
    loadWorldBossData();
  }
});

// 全域函數
window.challengeWorldBoss = challengeWorldBoss;
window.leaveWorldBoss = leaveWorldBoss;
window.closeBattleResult = closeBattleResult;
window.resetWorldBoss = resetWorldBoss; // 管理員功能

// 初始化
function initWorldBoss() {
  // 通知父視窗切換音樂
  window.parent.postMessage({ command: "switchToWorldBossMusic" }, "*");
  
  createPageParticles();
  startPageLoadingProgress();
  
  // 🔧 開發者模式：添加管理員控制
  if (isDeveloper) {
    const challengeArea = document.querySelector('.challenge-button-area');
    if (challengeArea) {
      const adminBtn = document.createElement('button');
      adminBtn.textContent = '🔧 重置世界王 (管理員)';
      adminBtn.style.cssText = `
        background: linear-gradient(135deg, #dc3545, #c82333);
        border: none;
        padding: 10px 20px;
        border-radius: 20px;
        color: white;
        font-family: 'Orbitron', sans-serif;
        font-weight: 600;
        cursor: pointer;
        margin-top: 10px;
        width: 100%;
        font-size: 0.9em;
      `;
      adminBtn.onclick = resetWorldBoss;
      challengeArea.appendChild(adminBtn);
      
      console.log('🔧 開發者模式已啟用，管理員功能可用');
    }
  }
  
  // 載入使用者等級和世界王資料
  setTimeout(async () => {
    await loadUserLevel();  // 先載入使用者等級
    await loadWorldBossData();
    hidePageLoading();
  }, 2000);
  
  // 開始倒數計時器
  updateCountdown();
  setInterval(updateCountdown, 1000);
}

// 監聽登入狀態
onAuthStateChanged(auth, async (user) => {
  if (user) {
    initWorldBoss();
  } else {
    window.parent.location.href = "/SFL/login.html";
  }
});
</script>
</body>
</html>
