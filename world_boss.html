<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<title>世界王挑戰</title>
<link rel="icon" href="favicon.ico" />
<link href="css/style.css" rel="stylesheet"/>
<link href="css/dungeon_layer_winning.css" rel="stylesheet"/>
<link href="css/dungeon_layer.css" rel="stylesheet"/>
<link href="css/world_boss.css" rel="stylesheet"/>
</head>
<body class="world-boss-mode">

<!-- 世界王血量條 -->
<div class="world-boss-hp-container">
  <div class="world-boss-title">🌍 世界王挑戰 🌍</div>
  <div class="world-hp-bar-container">
    <div class="world-hp-bar" id="worldHpBar" style="width: 100%;">
      <div class="world-hp-text" id="worldHpText">載入中...</div>
    </div>
  </div>
  <div class="world-boss-stats">
    <div class="world-stat-item">參與者: <span class="world-stat-value" id="participantCount">-</span></div>
    <div class="world-stat-item">等級: <span class="world-stat-value" id="bossLevel">80</span></div>
    <div class="world-stat-item">階段: <span class="world-stat-value" id="currentPhase">1 / 3</span></div>
  </div>
</div>

<!-- 階段指示器 -->
<div class="phase-indicator" id="phaseIndicator">
  載入階段資訊...
</div>

<!-- 倒數計時器 -->
<div class="countdown-timer">
  <div class="countdown-label">⏰ 挑戰開放倒數</div>
  <div class="countdown-value" id="countdownDisplay">計算中...</div>
</div>

<!-- 頁面載入遮罩 -->
<div id="loadingOverlay">
  <div class="particles" id="pageParticles"></div>
  <div class="battle-loading-container">
    <div class="battle-icon">🐲</div>
    <div class="battle-title normal-title">載入世界王</div>
    <div class="loading-text" id="pageLoadingText">正在連接世界王戰場...</div>
    <div class="progress-container">
      <div class="progress-bar" id="pageProgressBar"></div>
    </div>
    <div class="progress-text" id="pageProgressText">0%</div>
    <div class="battle-tips">
      🌍 全世界的冒險者正在一起戰鬥！<br/>
      ⚔️ 每一次攻擊都關乎人類的命運
    </div>
  </div>
</div>

<!-- 主要內容區域 -->
<div class="world-boss-container">
  <!-- 左側面板：玩家挑戰區域 -->
  <div class="left-panel">
    <!-- 時間限制提示（週日顯示） -->
    <div class="time-restriction-notice" id="timeRestriction" style="display: none;">
      <div class="restriction-title">⏰ 挑戰時間限制</div>
      <div class="restriction-message">
        世界王每週日進行休整，無法挑戰<br>
        挑戰將於下週一 00:00 重新開放
      </div>
    </div>

    <!-- 玩家挑戰卡片 -->
    <div class="player-challenge-card">
      <div class="player-damage-stats">
        <div class="damage-title">🏆 你的累積傷害</div>
        <div class="total-damage" id="playerTotalDamage">0</div>
        <div class="damage-rank" id="playerRank">排名: 未參與</div>
        <div style="margin-top: 10px; font-size: 0.9em; color: #ccc;">
          挑戰次數: <span id="challengeCount">0</span> 次
        </div>
      </div>
      
      <div class="challenge-button-area">
        <button class="world-challenge-btn" id="challengeBtn" onclick="challengeWorldBoss()">
          🌍 挑戰世界王 🌍
        </button>
        <div class="cooldown-info" id="cooldownInfo" style="display: none;">
          冷卻中，請等待：<span id="cooldownTimer">00:00</span>
        </div>
      </div>
    </div>
  </div>

  <!-- 世界王資訊 -->
    <div class="section world-boss-info-container">
      <div class="world-boss-name" id="bossName">載入中...</div>
      <div class="world-boss-phase" id="phaseDescription">載入階段資訊...</div>
      <img src="" class="world-boss-image" id="bossImage" width="250">
      <div class="world-boss-description" id="bossDescription">載入中...</div>
    </div>

  <!-- 右側面板：排行榜 -->
  <div class="right-panel">
    <div class="leaderboard-card">
      <div class="leaderboard-title">🏆 傷害排行榜</div>
      <div class="leaderboard-list" id="leaderboardList">
        <div style="text-align: center; color: #888; padding: 20px;">
          載入排行榜中...
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 勝利/戰鬥結果遮罩 -->
<div class="victory-overlay" id="battleResultOverlay" style="display: none;">
  <div class="victory-content">
    <div class="victory-icon" id="battleResultIcon">⚔️</div>
    <div class="victory-title" id="battleResultTitle">戰鬥結果</div>
    <div class="victory-message" id="battleResultMessage">結果訊息</div>
    <button class="effect-button" onclick="closeBattleResult()">確定</button>
  </div>
</div>

<script type="module">
import { auth, SecureAPI, PerformanceMonitor } from "./js/firebase-init.js";
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

const API_BASE = "https://sfl-9cb8.onrender.com";

let worldBossData = null;
let playerData = null;
let leaderboardData = [];
let cooldownTimer = null;
let currentUserNickname = "";

// 階段配置
const PHASES = {
  1: {
    name: "【第一階段】資料載入中",
    description: "資料載入中...",
    hp_threshold: 100
  },
  2: {
    name: "【第二階段】資料載入中",
    description: "資料載入中...",
    hp_threshold: 60
  },
  3: {
    name: "【第三階段】資料載入中",
    description: "資料載入中...",
    hp_threshold: 30
  }
};

// 載入頁面初始化
function createPageParticles() {
  const particlesContainer = document.getElementById("pageParticles");
  if (!particlesContainer) return;
  particlesContainer.innerHTML = "";
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement("div");
    particle.className = "particle";
    particle.style.left = Math.random() * 100 + "%";
    particle.style.animationDelay = Math.random() * 4 + "s";
    particle.style.animationDuration = (Math.random() * 2 + 3) + "s";
    particle.style.background = `rgba(${Math.random() > 0.5 ? '255, 215, 0' : '255, 140, 0'}, 0.8)`;
    particlesContainer.appendChild(particle);
  }
}

function startPageLoadingProgress() {
  const progressBar = document.getElementById("pageProgressBar");
  const progressText = document.getElementById("pageProgressText");
  const loadingText = document.getElementById("pageLoadingText");
  if (!progressBar || !progressText || !loadingText) return;

  const messages = [
    "正在連接世界王戰場...",
    "載入全球戰鬥資料...", 
    "同步世界王狀態...",
    "載入排行榜資料...",
    "連接完成！"
  ];

  let progress = 0;
  let messageIndex = 0;
  const progressInterval = setInterval(() => {
    progress += Math.random() * 15 + 10;
    if (progress > 100) progress = 100;

    progressBar.style.width = progress + "%";
    progressText.textContent = Math.round(progress) + "%";

    if (messageIndex < messages.length - 1 && progress > (messageIndex + 1) * 20) {
      messageIndex++;
      loadingText.textContent = messages[messageIndex];
    }

    if (progress >= 100) {
      clearInterval(progressInterval);
      loadingText.textContent = messages[messages.length - 1];
    }
  }, 300);

  window.pageLoadingInterval = progressInterval;
}

function showLoading(show) {
  const loading = document.getElementById("loadingOverlay");
  if (!loading) return;
  loading.style.display = show ? "flex" : "none";
}

function hidePageLoading() {
  if (window.pageLoadingInterval) {
    clearInterval(window.pageLoadingInterval);
  }
  setTimeout(() => {
    showLoading(false);
  }, 1000);
}

// 時間相關函數
function isWeekend() {
  const now = new Date();
  const taipeiTime = new Date(now.toLocaleString("en-US", {timeZone: "Asia/Taipei"}));
  return taipeiTime.getDay() === 0; // 週日
}

function getNextMondayCountdown() {
  const now = new Date();
  const taipeiTime = new Date(now.toLocaleString("en-US", {timeZone: "Asia/Taipei"}));
  
  // 找下週一 00:00
  const nextMonday = new Date(taipeiTime);
  const daysUntilMonday = (7 - taipeiTime.getDay() + 1) % 7;
  nextMonday.setDate(taipeiTime.getDate() + (daysUntilMonday === 0 ? 7 : daysUntilMonday));
  nextMonday.setHours(0, 0, 0, 0);
  
  const diff = nextMonday - taipeiTime;
  
  if (diff <= 0) return "00:00:00";
  
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// 更新倒數計時器
function updateCountdown() {
  const countdownEl = document.getElementById("countdownDisplay");
  const timeRestrictionEl = document.getElementById("timeRestriction");
  const challengeBtnEl = document.getElementById("challengeBtn");
  
  if (isWeekend()) {
    countdownEl.textContent = getNextMondayCountdown();
    timeRestrictionEl.style.display = "block";
    challengeBtnEl.disabled = true;
    challengeBtnEl.textContent = "⏰ 週日休整中";
  } else {
    timeRestrictionEl.style.display = "none";
    countdownEl.textContent = "挑戰開放中";
    if (!challengeBtnEl.dataset.cooling) {
      challengeBtnEl.textContent = "🌍 挑戰世界王 🌍";
    }
  }
}

// 更新冷卻時間顯示
function updateCooldownDisplay(cooldownEndTime) {
  const cooldownInfoEl = document.getElementById("cooldownInfo");
  const cooldownTimerEl = document.getElementById("cooldownTimer");
  const challengeBtnEl = document.getElementById("challengeBtn");
  
  if (!cooldownEndTime) {
    cooldownInfoEl.style.display = "none";
    challengeBtnEl.dataset.cooling = "false";
    if (!isWeekend()) {
      challengeBtnEl.disabled = false;
      challengeBtnEl.textContent = "🌍 挑戰世界王 🌍";
    }
    return;
  }
  
  const now = Date.now();
  const remaining = cooldownEndTime - now;
  
  if (remaining <= 0) {
    cooldownInfoEl.style.display = "none";
    challengeBtnEl.dataset.cooling = "false";
    if (!isWeekend()) {
      challengeBtnEl.disabled = false;
      challengeBtnEl.textContent = "🌍 挑戰世界王 🌍";
    }
    if (cooldownTimer) {
      clearInterval(cooldownTimer);
      cooldownTimer = null;
    }
    return;
  }
  
  const minutes = Math.floor(remaining / (1000 * 60));
  const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
  
  cooldownInfoEl.style.display = "block";
  cooldownTimerEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  challengeBtnEl.disabled = true;
  challengeBtnEl.dataset.cooling = "true";
  challengeBtnEl.textContent = "⏰ 冷卻中";
}

// 階段系統
function getCurrentPhase(currentHp, maxHp) {
  const percentage = (currentHp / maxHp) * 100;
  
  // 使用 API 資料中的 hp_threshold
  if (worldBossData?.phases) {
    const phases = worldBossData.phases;
    
    // 從最低階段開始檢查
    if (percentage <= (phases["3"]?.hp_threshold || 30)) return 3;
    if (percentage <= (phases["2"]?.hp_threshold || 60)) return 2;
    return 1;
  }
  
  // 降級處理：使用硬編碼值
  if (percentage > 60) return 1;
  if (percentage > 30) return 2;
  return 3;
}

function updatePhaseDisplay(phase) {
  const phaseIndicatorEl = document.getElementById("phaseIndicator");
  const phaseDescriptionEl = document.getElementById("phaseDescription");
  const currentPhaseEl = document.getElementById("currentPhase");
  
  const phaseInfo = worldBossData?.phases?.[phase.toString()];
  if (phaseInfo) {
    phaseIndicatorEl.textContent = phaseInfo.name;
    phaseDescriptionEl.textContent = phaseInfo.description;
    currentPhaseEl.textContent = `${phase} / 3`;
  } else {
    phaseIndicatorEl.textContent = `【第${phase}階段】`;
    phaseDescriptionEl.textContent = "階段資料載入中...";
    currentPhaseEl.textContent = `${phase} / 3`;
  }
}

// 更新世界王血量和階段
function updateWorldBossHP(current, max) {
  const hpBar = document.getElementById("worldHpBar");
  const hpText = document.getElementById("worldHpText");
  
  const percentage = Math.max(0, (current / max) * 100);
  hpBar.style.width = percentage + "%";
  hpText.textContent = `${current.toLocaleString()} / ${max.toLocaleString()} (${percentage.toFixed(1)}%)`;
  
  // 更新階段
  const currentPhase = getCurrentPhase(current, max);
  updatePhaseDisplay(currentPhase);
}

// 更新玩家傷害顯示
function updatePlayerDamage(damage, rank, challengeCount = 0) {
  const damageEl = document.getElementById("playerTotalDamage");
  const rankEl = document.getElementById("playerRank");
  const countEl = document.getElementById("challengeCount");
  
  damageEl.textContent = damage.toLocaleString();
  rankEl.textContent = rank > 0 ? `排名: #${rank}` : "排名: 未參與";
  countEl.textContent = challengeCount;
}

// 更新排行榜
function updateLeaderboard(leaderboard) {
  const listEl = document.getElementById("leaderboardList");
  
  if (!leaderboard || leaderboard.length === 0) {
    listEl.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">暫無排行榜資料</div>';
    return;
  }
  
  // 🎯 限制只顯示前10名
  const top10 = leaderboard.slice(0, 10);
  
  let html = '';
  top10.forEach((player, index) => {
    const rank = index + 1;
    const isCurrentPlayer = player.nickname === currentUserNickname;
    const isTop3 = rank <= 3;
    
    let rankClass = '';
    if (rank === 1) rankClass = 'top-1';
    else if (rank === 2) rankClass = 'top-2';
    else if (rank === 3) rankClass = 'top-3';
    
    let itemClass = 'leaderboard-item';
    if (isTop3) itemClass += ' top-3';
    if (isCurrentPlayer) itemClass += ' current-player';
    
    html += `
      <div class="${itemClass}">
        <div class="rank-number ${rankClass}">#${rank}</div>
        <div class="player-name">${player.nickname}${isCurrentPlayer ? ' (你)' : ''}</div>
        <div class="damage-amount">${player.total_damage.toLocaleString()}</div>
      </div>
    `;
  });
  
  // 🎯 如果當前玩家不在前10名，額外顯示自己的排名
  if (currentUserNickname) {
    const currentPlayerInTop10 = top10.find(p => p.nickname === currentUserNickname);
    
    if (!currentPlayerInTop10 && playerData && playerData.rank > 10) {
      // 找到當前玩家在完整排行榜中的資料
      const currentPlayerData = leaderboard.find(p => p.nickname === currentUserNickname);
      
      if (currentPlayerData) {
        html += `
          <div class="leaderboard-divider" style="margin: 15px 0; border-top: 1px solid rgba(255,215,0,0.3); text-align: center; padding-top: 10px;">
            <span style="color: #ffd700; font-size: 0.9em;">--- 你的排名 ---</span>
          </div>
          <div class="leaderboard-item current-player">
            <div class="rank-number">#${playerData.rank}</div>
            <div class="player-name">${currentPlayerData.nickname} (你)</div>
            <div class="damage-amount">${currentPlayerData.total_damage.toLocaleString()}</div>
          </div>
        `;
      }
    }
  }
  
  // 🎯 添加顯示說明
  if (leaderboard.length > 10) {
    html += `
      <div style="text-align: center; color: #888; padding: 15px 10px; font-size: 0.85em; border-top: 1px solid rgba(255,255,255,0.1); margin-top: 10px;">
        顯示前 10 名 / 共 ${leaderboard.length} 名參與者
      </div>
    `;
  }
  
  listEl.innerHTML = html;
}

// 載入世界王資料
async function loadWorldBossData() {
  try {
    PerformanceMonitor.startTiming('loadWorldBoss');
    
    // 🚀 先檢查世界王是否已初始化
    try {
      const initCheckRes = await SecureAPI.get(`${API_BASE}/world_boss_init_check`);
      const initResult = await initCheckRes.json();
      if (!initResult.initialized) {
        console.warn('世界王未初始化:', initResult.error);
      }
    } catch (initError) {
      console.warn('世界王初始化檢查失敗:', initError);
    }
    
    // 並行載入世界王資料和排行榜
    const [bossRes, leaderboardRes, playerRes] = await Promise.all([
      SecureAPI.get(`${API_BASE}/world_boss_status`),
      // 🎯 請求更多數據以便前端篩選，或者後端限制為50名避免性能問題
      SecureAPI.get(`${API_BASE}/world_boss_leaderboard?limit=50`),
      SecureAPI.get(`${API_BASE}/world_boss_player_data`)
    ]);
    
    if (bossRes.ok) {
      worldBossData = await bossRes.json();
      if (worldBossData.phases) {
        console.log('✅ 階段資料載入成功:', Object.keys(worldBossData.phases));
      } else {
        console.warn('⚠️ 階段資料載入失敗');
      }
      
      updateWorldBossInfo(worldBossData);
    } else {
      throw new Error(`載入世界王狀態失敗: ${bossRes.status}`);
    }
    
    if (leaderboardRes.ok) {
      const leaderboardResult = await leaderboardRes.json();
      // 🎯 傳入完整的排行榜數據，讓前端處理顯示邏輯
      updateLeaderboard(leaderboardResult.leaderboard || []);
    } else {
      console.warn('載入排行榜失敗:', leaderboardRes.status);
      updateLeaderboard([]);
    }
    
    if (playerRes.ok) {
      playerData = await playerRes.json();
      updatePlayerDamage(playerData.total_damage, playerData.rank, playerData.challenge_count);
      
      // 如果有冷卻時間，開始倒數
      if (playerData.cooldown_end_time) {
        startCooldownTimer(playerData.cooldown_end_time);
      }
    } else {
      console.warn('載入玩家數據失敗:', playerRes.status);
      updatePlayerDamage(0, 0, 0);
    }
    
    console.log('✅ 世界王資料載入完成');
    
  } catch (error) {
    console.error('載入世界王資料失敗:', error);
    document.getElementById("bossName").textContent = "載入失敗";
    document.getElementById("leaderboardList").innerHTML = 
      '<div style="text-align: center; color: #ff6b6b; padding: 20px;">載入失敗，請重新整理頁面</div>';
      
    // 顯示錯誤提示
    showBattleResult(false, "載入錯誤", "無法載入世界王資料，請檢查網路連線並重新整理頁面");
  } finally {
    PerformanceMonitor.endTiming('loadWorldBoss');
  }
}

function updateWorldBossInfo(boss) {
  document.getElementById("bossName").innerHTML = boss.name.replace(/\n/g, "<br>");
  document.getElementById("bossImage").src = boss.image;
  document.getElementById("bossDescription").textContent = boss.description;
  document.getElementById("bossLevel").textContent = boss.level;
  document.getElementById("participantCount").textContent = boss.total_participants.toLocaleString();
  
  updateWorldBossHP(boss.current_hp, boss.max_hp);
  
  const currentPhase = getCurrentPhase(boss.current_hp, boss.max_hp);
  updatePhaseDisplay(currentPhase);
}

// 開始冷卻計時器
function startCooldownTimer(endTime) {
  if (cooldownTimer) {
    clearInterval(cooldownTimer);
  }
  
  cooldownTimer = setInterval(() => {
    updateCooldownDisplay(endTime);
  }, 1000);
  
  updateCooldownDisplay(endTime);
}

// 顯示戰鬥結果
function showBattleResult(success, title, message, damage = 0) {
  const overlay = document.getElementById("battleResultOverlay");
  const icon = document.getElementById("battleResultIcon");
  const titleEl = document.getElementById("battleResultTitle");
  const messageEl = document.getElementById("battleResultMessage");
  
  if (success) {
    // 🎨 根據標題設定不同的背景顏色
    if (title.includes("完美攻擊")) {
      // S級 - 金色漸層
      overlay.style.background = "linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 165, 0, 0.9), rgba(255, 140, 0, 0.95))";
    } else if (title.includes("強力攻擊")) {
      // A級 - 紫色漸層
      overlay.style.background = "linear-gradient(135deg, rgba(138, 43, 226, 0.9), rgba(75, 0, 130, 0.85), rgba(148, 0, 211, 0.9))";
    } else if (title.includes("有效攻擊")) {
      // B級 - 藍色漸層
      overlay.style.background = "linear-gradient(135deg, rgba(0, 100, 255, 0.9), rgba(0, 150, 255, 0.85), rgba(30, 144, 255, 0.9))";
    } else {
      // C級或預設 - 綠色漸層
      overlay.style.background = "linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 140, 0, 0.8), rgba(255, 69, 0, 0.9))";
    }
    
    icon.textContent = title.charAt(0); // 使用標題的第一個字符作為圖示
    titleEl.textContent = title;
    messageEl.innerHTML = message;
  } else {
    icon.textContent = "❌";
    titleEl.textContent = title || "挑戰失敗";
    messageEl.textContent = message || "挑戰過程發生錯誤";
    overlay.style.background = "linear-gradient(135deg, rgba(139, 0, 0, 0.9), rgba(220, 20, 60, 0.8), rgba(75, 0, 130, 0.9))";
  }
  
  overlay.style.display = "flex";
}

function closeBattleResult() {
  document.getElementById("battleResultOverlay").style.display = "none";
}

// 挑戰世界王
async function challengeWorldBoss() {
  if (isWeekend()) {
    showBattleResult(false, "時間限制", "世界王於週日休整，請於週一再來挑戰！");
    return;
  }
  
  const challengeBtnEl = document.getElementById("challengeBtn");
  if (challengeBtnEl.disabled) return;
  
  challengeBtnEl.disabled = true;
  challengeBtnEl.textContent = "⚔️ 戰鬥中...";
  
  try {
    const response = await SecureAPI.post(`${API_BASE}/world_boss_challenge`, {});
    const result = await response.json();
    
    if (response.ok && result.success) {
      // 🚀 新的戰鬥成功顯示，包含傷害百分比和獎勵等級
      const message = `
        <div style="text-align: left; line-height: 1.6;">
          <div style="margin-bottom: 15px;">
            <div style="font-size: 1.3em; color: #ffd700; margin-bottom: 8px;">
              ${result.reward_tier} - ${result.tier_description}
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
              造成傷害：<span style="color: #ff6b6b; font-weight: bold;">${result.damage_dealt.toLocaleString()}</span><br>
              傷害百分比：<span style="color: #00ffff; font-weight: bold;">${result.damage_percentage.toFixed(4)}%</span><br>
              獲得經驗：<span style="color: #ffd700; font-weight: bold;">+${result.exp_gained.toLocaleString()}</span>
            </div>
            <div style="background: rgba(0,255,255,0.1); padding: 8px; border-radius: 6px;">
              累積傷害：${result.total_damage.toLocaleString()}<br>
              當前排名：#${result.current_rank}
            </div>
          </div>
        </div>
      `;
      
      // 🎯 根據獎勵等級顯示不同的標題和圖示
      let title = "⚔️ 戰鬥成功！";
      let icon = "⚔️";
      
      switch(result.reward_tier) {
        case "S級傷害":
          title = "🌟 完美攻擊！";
          icon = "🌟";
          break;
        case "A級傷害":
          title = "💥 強力攻擊！";
          icon = "💥";
          break;
        case "B級傷害":
          title = "⚔️ 有效攻擊！";
          icon = "⚔️";
          break;
        case "C級傷害":
          title = "🛡️ 成功命中！";
          icon = "🛡️";
          break;
      }
      
      showBattleResult(true, title, message, result.damage_dealt);
      
      // 更新顯示
      updatePlayerDamage(result.total_damage, result.current_rank, playerData.challenge_count + 1);
      
      // 重新載入排行榜和世界王狀態
      setTimeout(() => {
        loadWorldBossData();
      }, 1000);
      
      // 開始冷卻計時
      startCooldownTimer(result.cooldown_end_time);
      
    } else {
      showBattleResult(false, "挑戰失敗", result.error || "未知錯誤");
      challengeBtnEl.disabled = false;
      challengeBtnEl.textContent = "🌍 挑戰世界王 🌍";
    }
    
  } catch (error) {
    console.error('挑戰世界王失敗:', error);
    showBattleResult(false, "連線錯誤", "挑戰過程發生錯誤，請稍後再試");
    challengeBtnEl.disabled = false;
    challengeBtnEl.textContent = "🌍 挑戰世界王 🌍";
  }
}

// 離開世界王戰場
function leaveWorldBoss() {
  window.parent.postMessage({ command: "restoreMainMusic" }, "*");
  setTimeout(() => {
    window.parent.loadPage('main_page.html');
  }, 300);
}

// 🔧 管理員功能：重置世界王（開發/測試用）
async function resetWorldBoss() {
  if (!confirm('⚠️ 確定要重置世界王嗎？\n這將重置血量和所有統計數據！\n\n是否同時清除排行榜？\n點確定=清除排行榜，取消=保留排行榜')) {
    return;
  }
  
  const clearLeaderboard = confirm('是否清除排行榜？\n確定=清除，取消=保留');
  
  try {
    const response = await SecureAPI.post(`${API_BASE}/world_boss_reset`, {
      clear_leaderboard: clearLeaderboard
    });
    const result = await response.json();
    
    if (response.ok) {
      showBattleResult(true, "重置成功", `世界王已重置！\n${clearLeaderboard ? '排行榜已清除' : '排行榜已保留'}`);
      setTimeout(() => {
        loadWorldBossData();
      }, 2000);
    } else {
      showBattleResult(false, "重置失敗", result.error);
    }
  } catch (error) {
    showBattleResult(false, "重置錯誤", "重置過程發生錯誤：" + error.message);
  }
}

// 🔧 開發者模式檢測
const isDeveloper = window.location.hostname === 'localhost' || 
                   window.location.search.includes('debug=true') ||
                   window.location.search.includes('admin=true');

// 強制刷新功能（父視窗調用）
window.addEventListener('message', (event) => {
  if (event.data && event.data.command === 'forceRefresh') {
    console.log('收到強制刷新指令');
    loadWorldBossData();
  }
});

// 全域函數
window.challengeWorldBoss = challengeWorldBoss;
window.leaveWorldBoss = leaveWorldBoss;
window.closeBattleResult = closeBattleResult;
window.resetWorldBoss = resetWorldBoss; // 管理員功能

// 初始化
function initWorldBoss() {
  // 通知父視窗切換音樂
  window.parent.postMessage({ command: "switchToWorldBossMusic" }, "*");
  
  createPageParticles();
  startPageLoadingProgress();
  
  // 🔧 開發者模式：添加管理員控制
  if (isDeveloper) {
    const challengeArea = document.querySelector('.challenge-button-area');
    if (challengeArea) {
      const adminBtn = document.createElement('button');
      adminBtn.textContent = '🔧 重置世界王 (管理員)';
      adminBtn.style.cssText = `
        background: linear-gradient(135deg, #dc3545, #c82333);
        border: none;
        padding: 10px 20px;
        border-radius: 20px;
        color: white;
        font-family: 'Orbitron', sans-serif;
        font-weight: 600;
        cursor: pointer;
        margin-top: 10px;
        width: 100%;
        font-size: 0.9em;
      `;
      adminBtn.onclick = resetWorldBoss;
      challengeArea.appendChild(adminBtn);
      
      console.log('🔧 開發者模式已啟用，管理員功能可用');
    }
  }
  
  // 載入世界王資料
  setTimeout(async () => {
    await loadWorldBossData();
    hidePageLoading();
  }, 2000);
  
  // 開始倒數計時器
  updateCountdown();
  setInterval(updateCountdown, 1000);
}

// 階段資料驗證函數
function validatePhaseData() {
  if (!worldBossData || !worldBossData.phases) {
    console.warn('階段資料未載入或格式錯誤');
    return false;
  }
  
  const phases = worldBossData.phases;
  const requiredFields = ['name', 'description', 'hp_threshold'];
  
  for (const [phaseKey, phaseData] of Object.entries(phases)) {
    for (const field of requiredFields) {
      if (!phaseData[field] && phaseData[field] !== 0) {
        console.error(`階段 ${phaseKey} 缺少必要欄位: ${field}`);
        return false;
      }
    }
  }
  
  console.log('✅ 階段資料驗證通過');
  return true;
}
  
// 載入使用者暱稱
async function loadUserNickname() {
  try {
    const statusRes = await SecureAPI.getStatus(false);
    const userData = await statusRes.json();
    currentUserNickname = userData.nickname || userData.user_id;
  } catch (error) {
    console.warn('載入使用者暱稱失敗:', error);
  }
}

// 監聽登入狀態
onAuthStateChanged(auth, async (user) => {
  if (user) {
    await loadUserNickname();
    initWorldBoss();
  } else {
    window.parent.location.href = "/SFL/login.html";
  }
});
</script>
</body>
</html>
