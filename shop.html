<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>æ¬¡å…ƒå•†åº—</title>
  <link rel="icon" href="favicon.ico" />
  <link href="css/inventory.css" rel="stylesheet"/>
  <link href="css/shop.css" rel="stylesheet"/>
</head>
<body>
  <div id="initialOverlay">è¼‰å…¥ä¸­...</div>
  <div id="loading-placeholder"></div>
  <script src="js/loading.js"></script>
  <script>
    fetch("loadingOverlay.html")
      .then(res => res.text())
      .then(html => {
        document.getElementById("loading-placeholder").innerHTML = html;
        document.getElementById("initialOverlay")?.remove();
        if (typeof startPageLoadingProgress === "function") startPageLoadingProgress();
      });
  </script>

  <h1 class="fancy-title">æ¬¡å…ƒå•†åº—</h1>

  <div class="user-section-row">
    <div class="user-currency half">
      <h2 class="fancy-subtitle">ğŸ‘¤ ç©å®¶è¨Šæ¯</h2>
      <div id="userInfoDisplay">è¼‰å…¥ä¸­...</div>
    </div>
  
    <div class="user-currency half">
      <h2 class="fancy-subtitle">ğŸ’° æŒæœ‰äº¤æ›é“å…·</h2>
      <div id="userCurrencyDisplay">è¼‰å…¥ä¸­...</div>
    </div>
  </div>
  
  <!-- é‡ç½®æ™‚é–“é¡¯ç¤º -->
  <div class="reset-timer">
    <h3>â° å•†åº—é‡ç½®æ™‚é–“</h3>
    <div id="resetTimerDisplay">è¼‰å…¥ä¸­...</div>
  </div>
  
  <!-- åˆ†é¡ç¯©é¸ -->
  <div class="shop-filters">
    <button class="filter-btn active" data-category="all">å…¨éƒ¨å•†å“ <span class="category-count" id="count-all">0</span></button>
    <button class="filter-btn" data-category="reset_free">å®šæœŸå…è²» <span class="category-count" id="count-reset_free">0</span></button>
    <button class="filter-btn" data-category="level_pack">ç­‰ç´šç¦®åŒ… <span class="category-count" id="count-level_pack">0</span></button>
    <button class="filter-btn" data-category="world_boss">ä¸–ç•Œç‹ <span class="category-count" id="count-world_boss">0</span></button>
  </div>
  
  <!-- å•†å“å±•ç¤ºå€ -->
  <div class="items-section">
    <h2 class="fancy-subtitle">ğŸ›’ å•†å“åˆ—è¡¨</h2>
    <div class="item-grid" id="shopItemGrid"></div>
  </div>
  
  <!-- è³¼è²·ç¢ºèªå°è©±æ¡† -->
  <div id="dialogContainer"></div>
  <div id="loadingSpinner" class="loading-spinner">è™•ç†ä¸­...</div>

  <script type="module">
    import { auth, SecureAPI, PerformanceMonitor } from "./js/firebase-init.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    const API_BASE = "https://sfl-9cb8.onrender.com";
    
    // ğŸ¯ ç°¡åŒ–çš„å…¨åŸŸç‹€æ…‹
    let gameData = {
      shopItems: [],
      userItems: {},
      userPurchases: {},
      itemMeta: {},
      userData: {}
    };
    
    let uiState = {
      currentFilter: 'all',
      isPurchasing: false // é˜²æ­¢ç‹‚é»
    };

    // ğŸ›¡ï¸ é¡¯ç¤º/éš±è—è¼‰å…¥ç•«é¢
    function showLoading(show) {
      const loading = document.getElementById("loadingOverlay");
      const spinner = document.getElementById("loadingSpinner");
      if (loading) loading.style.display = show ? "flex" : "none";
      if (spinner) spinner.style.display = show ? "block" : "none";
    }

    // ğŸ• ç°¡åŒ–çš„æ™‚é–“è™•ç†
    function getTaipeiTime() {
      return new Date(new Date().toLocaleString("en-US", {timeZone: "Asia/Taipei"}));
    }

    // ğŸ“Š è¼‰å…¥æ‰€æœ‰å¿…è¦æ•¸æ“š
    async function loadAllData() {
      try {
        console.log("ğŸ”„ é–‹å§‹è¼‰å…¥å•†åº—æ•¸æ“š...");
        
        const [shopRes, itemsRes, userItemsRes, userRes, purchasesRes] = await Promise.all([
          fetch("parameter/shop_items.json"),
          SecureAPI.getStaticData('items_table'),
          SecureAPI.get(`${API_BASE}/user_items`, false),
          SecureAPI.getStatus(false),
          SecureAPI.get(`${API_BASE}/shop_user_purchases`, false)
        ]);

        // è™•ç†å•†åº—ç‰©å“
        gameData.shopItems = await shopRes.json();
        
        // è™•ç†ç‰©å“å…ƒæ•¸æ“š
        if (Array.isArray(itemsRes)) {
          gameData.itemMeta = itemsRes.reduce((acc, item) => {
            acc[item.id] = item;
            return acc;
          }, {});
        } else {
          gameData.itemMeta = itemsRes;
        }

        // è™•ç†ç”¨æˆ¶æ•¸æ“š
        gameData.userItems = userItemsRes.ok ? (await userItemsRes.json()).items || {} : {};
        gameData.userData = await userRes.json();
        
        // è™•ç†è³¼è²·è¨˜éŒ„
        if (purchasesRes.ok) {
          gameData.userPurchases = await purchasesRes.json();
        } else {
          gameData.userPurchases = {
            user_id: auth.currentUser?.email,
            purchases: {}
          };
        }
        
        console.log("âœ… æ‰€æœ‰æ•¸æ“šè¼‰å…¥å®Œæˆ");
        return true;
        
      } catch (error) {
        console.error("âŒ è¼‰å…¥æ•¸æ“šå¤±æ•—:", error);
        throw error;
      }
    }

    // ğŸ‘¤ æ›´æ–°ç”¨æˆ¶ä¿¡æ¯é¡¯ç¤º
    function updateUserInfoDisplay() {
      const userLevel = gameData.userData.level || 1;
      const userNickname = gameData.userData.nickname || "æœªçŸ¥ç©å®¶";
      
      document.getElementById("userInfoDisplay").innerHTML = `
        <div class="currency-item">
          <span class="currency-name">æš±ç¨±:</span>
          <span class="currency-amount">${userNickname}</span>
        </div>
        <div class="currency-item">
          <span class="currency-name">ç­‰ç´š:</span>
          <span class="currency-amount">Lv.${userLevel}</span>
        </div>
      `;
    }

    // ğŸ’° æ›´æ–°è²¨å¹£é¡¯ç¤º
    function updateUserCurrencyDisplay() {
      const currencies = ['world_boss_token', 'daily_coin'];
      let html = '';
      
      currencies.forEach(currency => {
        const meta = gameData.itemMeta[currency];
        const amount = gameData.userItems[currency] || 0;
        const name = meta ? meta.name : currency;
        
        html += `
          <div class="currency-item">
            <span class="currency-name">${name}:</span>
            <span class="currency-amount">${amount}</span>
          </div>
        `;
      });
      
      document.getElementById("userCurrencyDisplay").innerHTML = html;
    }

    // â° æ›´æ–°é‡ç½®æ™‚é–“é¡¯ç¤º
    function updateResetTimerDisplay() {
      const now = getTaipeiTime();
      
      // è¨ˆç®—å„ç¨®é‡ç½®æ™‚é–“
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      tomorrow.setHours(0, 0, 0, 0);
      
      const nextMonday = new Date(now);
      const daysToMonday = (1 + 7 - now.getDay()) % 7 || 7;
      nextMonday.setDate(now.getDate() + daysToMonday);
      nextMonday.setHours(0, 0, 0, 0);
      
      const nextMonth = new Date(now);
      nextMonth.setMonth(now.getMonth() + 1, 1);
      nextMonth.setHours(0, 0, 0, 0);
      
      const formatTime = (date) => {
        const diff = date - now;
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        
        if (hours >= 24) {
          const days = Math.floor(hours / 24);
          return `${days}å¤© ${hours % 24}å°æ™‚`;
        }
        return `${hours}å°æ™‚ ${minutes}åˆ†`;
      };
      
      document.getElementById("resetTimerDisplay").innerHTML = `
        <div class="timer-item">ğŸŒ… æ¯æ—¥é‡ç½®: ${formatTime(tomorrow)}</div>
        <div class="timer-item">ğŸ—“ï¸ æ¯é€±é‡ç½®: ${formatTime(nextMonday)}</div>
        <div class="timer-item">ğŸ“… æ¯æœˆé‡ç½®: ${formatTime(nextMonth)}</div>
        <div style="margin-top: 10px; font-size: 0.9em; color: #888;">
          â„¹ï¸ é‡ç½®å°‡åœ¨ä¸‹æ¬¡é€²å…¥å•†åº—æ™‚ç”Ÿæ•ˆ
        </div>
      `;
    }

    // ğŸ›’ æª¢æŸ¥å•†å“æ˜¯å¦å¯è³¼è²·
    function canPurchaseItem(item) {
      const purchases = gameData.userPurchases.purchases || {};
      const itemPurchases = purchases[item.id] || {
        total_purchased: 0,
        daily_purchased: 0,
        weekly_purchased: 0,
        monthly_purchased: 0
      };
      
      const userLevel = gameData.userData.level || 1;
      
      // æª¢æŸ¥ç­‰ç´šé™åˆ¶
      if (userLevel < (item.required_level || 1)) {
        return { 
          canPurchase: false, 
          reason: `ç­‰ç´šä¸è¶³ (éœ€è¦Lv.${item.required_level}ï¼Œç›®å‰Lv.${userLevel})`
        };
      }
      
      // æª¢æŸ¥ç¸½é™è³¼
      if (item.limit_per_account > 0 && itemPurchases.total_purchased >= item.limit_per_account) {
        return { canPurchase: false, reason: "å·²é”è³¼è²·ä¸Šé™" };
      }
      
      // æª¢æŸ¥é€±æœŸé™è³¼
      if (item.reset_type !== "none" && item.limit_per_reset > 0) {
        const resetKey = `${item.reset_type}_purchased`;
        if (itemPurchases[resetKey] >= item.limit_per_reset) {
          const typeName = { daily: 'æ¯æ—¥', weekly: 'æ¯é€±', monthly: 'æ¯æœˆ' }[item.reset_type];
          return { canPurchase: false, reason: `å·²é”${typeName}è³¼è²·ä¸Šé™` };
        }
      }
      
      // æª¢æŸ¥è³‡æºæ˜¯å¦è¶³å¤ 
      if (item.cost) {
        for (const [costItem, costAmount] of Object.entries(item.cost)) {
          const owned = gameData.userItems[costItem] || 0;
          if (owned < costAmount) {
            const itemName = gameData.itemMeta[costItem]?.name || costItem;
            return { canPurchase: false, reason: `${itemName} ä¸è¶³` };
          }
        }
      }
      
      return { canPurchase: true };
    }

    // ğŸ·ï¸ ç²å–ç‰©å“ä¸­æ–‡åç¨±
    function getItemName(itemId) {
      return gameData.itemMeta[itemId]?.name || itemId;
    }

    // ğŸ¨ æ¸²æŸ“å•†å“åˆ—è¡¨
    function renderShopItems() {
      const filteredItems = uiState.currentFilter === 'all' 
        ? gameData.shopItems 
        : gameData.shopItems.filter(item => item.category === uiState.currentFilter);

      const sortedItems = filteredItems.sort((a, b) => {
        // å¯è³¼è²·çš„æ’å‰é¢
        const aCanPurchase = canPurchaseItem(a).canPurchase;
        const bCanPurchase = canPurchaseItem(b).canPurchase;
        if (aCanPurchase !== bCanPurchase) return bCanPurchase ? 1 : -1;
        
        return (a.sort || 999) - (b.sort || 999);
      });

      let html = '';
      
      sortedItems.forEach(item => {
        const { canPurchase, reason } = canPurchaseItem(item);
        const purchases = gameData.userPurchases.purchases || {};
        const itemPurchases = purchases[item.id] || {};
        
        // å¡ç‰‡æ¨£å¼
        let cardClass = 'shop-item-card';
        if (!canPurchase) cardClass += ' sold-out';
        if (!item.cost || Object.keys(item.cost).length === 0) cardClass += ' free';
        if (item.type === 'bundle') cardClass += ' bundle';
        
        // ç‰¹æ®Šæ¨™è¨˜
        let specialLabel = '';
        if (item.special === 1) specialLabel = 'ã€ç¨€æœ‰ã€‘';
        else if (item.special === 2) specialLabel = 'ã€è¶…ç¨€æœ‰ã€‘';
        else if (item.special === 3) specialLabel = 'ã€ç½•è¦‹ã€‘';
        
        // ç²å¾—ç‰©å“é¡¯ç¤º
        let rewardHtml = '';
        if (item.type === 'bundle' && item.items) {
          const itemList = item.items.map(i => `${getItemName(i.item_id)} x${i.quantity}`).join('ã€');
          rewardHtml = `<div class="shop-item-desc">ğŸ“¦ ç²å¾—ï¼š${itemList}</div>`;
        } else if (item.item_id) {
          rewardHtml = `<div class="shop-item-desc">ğŸ“¦ ç²å¾—ï¼š${getItemName(item.item_id)} x${item.quantity}</div>`;
        }
        
        // æ¶ˆè²»é¡¯ç¤º
        let costHtml = '';
        if (!item.cost || Object.keys(item.cost).length === 0) {
          costHtml = '<div style="color: #4CAF50; text-align: center;">ğŸ’° å…è²»</div>';
        } else {
          costHtml = '<div class="shop-item-cost">';
          Object.entries(item.cost).forEach(([costItem, amount]) => {
            const owned = gameData.userItems[costItem] || 0;
            const sufficient = owned >= amount;
            costHtml += `
              <div class="cost-item">
                <span class="cost-name">${getItemName(costItem)}:</span>
                <div>
                  <span class="cost-amount">${amount}</span>
                  <span class="cost-owned ${sufficient ? '' : 'cost-insufficient'}">(æœ‰: ${owned})</span>
                </div>
              </div>
            `;
          });
          costHtml += '</div>';
        }
        
        // è³¼è²·é™åˆ¶é¡¯ç¤º
        const totalPurchased = itemPurchases.total_purchased || 0;
        let limitHtml = '';
        
        if (item.limit_per_account > 0) {
          limitHtml += `ç¸½è³¼è²·: ${totalPurchased}/${item.limit_per_account}`;
        }
        
        if (item.reset_type !== 'none' && item.limit_per_reset > 0) {
          const resetPurchased = itemPurchases[`${item.reset_type}_purchased`] || 0;
          const typeName = { daily: 'æ¯æ—¥', weekly: 'æ¯é€±', monthly: 'æ¯æœˆ' }[item.reset_type];
          if (limitHtml) limitHtml += ' | ';
          limitHtml += `${typeName}: ${resetPurchased}/${item.limit_per_reset}`;
        }
        
        html += `
          <div class="${cardClass}">
            <div class="shop-item-name">${specialLabel}${item.name}</div>
            <div class="shop-item-desc">${item.description}</div>
            ${rewardHtml}
            
            ${limitHtml ? `<div class="shop-item-limit">${limitHtml}</div>` : ''}
            
            ${costHtml}
            
            ${!canPurchase ? 
              `<div style="color: #ff6b6b; text-align: center; margin: 10px 0;">âŒ ${reason}</div>` :
              `<button class="square-btn purchase-btn" data-item-id="${item.id}" style="width: 100%; margin-top: 10px;">
                ${(!item.cost || Object.keys(item.cost).length === 0) ? 'ğŸ é ˜å–' : 'ğŸ’° è³¼è²·'}
              </button>`
            }
          </div>
        `;
      });
      
      document.getElementById("shopItemGrid").innerHTML = html || '<div class="shop-item-card">æ­¤åˆ†é¡æš«ç„¡å•†å“</div>';
      
      // ğŸ¯ é‡æ–°ç¶å®šè³¼è²·æŒ‰éˆ•äº‹ä»¶
      document.querySelectorAll('.purchase-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          if (!uiState.isPurchasing) {
            openPurchaseDialog(btn.dataset.itemId);
          }
        });
      });
      
      updateCategoryCounts();
    }

    // ğŸ“Š æ›´æ–°åˆ†é¡è¨ˆæ•¸
    function updateCategoryCounts() {
      const categories = ['all', 'reset_free', 'level_pack', 'world_boss'];
      categories.forEach(category => {
        const count = category === 'all' 
          ? gameData.shopItems.length 
          : gameData.shopItems.filter(item => item.category === category).length;
        
        const countEl = document.getElementById(`count-${category}`);
        if (countEl) countEl.textContent = count;
      });
    }

    // ğŸ›’ æ‰“é–‹è³¼è²·å°è©±æ¡†
    function openPurchaseDialog(itemId) {
      const item = gameData.shopItems.find(i => i.id === itemId);
      if (!item) return;
      
      const { canPurchase, reason } = canPurchaseItem(item);
      if (!canPurchase) {
        alert(`ç„¡æ³•è³¼è²·ï¼š${reason}`);
        return;
      }
      
      const dialog = document.getElementById("dialogContainer");
      const isFree = !item.cost || Object.keys(item.cost).length === 0;
      
      let rewardHtml = '';
      if (item.type === 'bundle' && item.items) {
        rewardHtml = '<h4>ğŸ“¦ ç¦®åŒ…å…§å®¹</h4>';
        item.items.forEach(i => {
          rewardHtml += `<div>${getItemName(i.item_id)} x${i.quantity}</div>`;
        });
      } else if (item.item_id) {
        rewardHtml = `<h4>ğŸ“¦ ç²å¾—ç‰©å“</h4><div>${getItemName(item.item_id)} x${item.quantity}</div>`;
      }
      
      let costHtml = '';
      if (isFree) {
        costHtml = '<div style="color: #4CAF50;">ğŸ å…è²»é ˜å–</div>';
      } else {
        costHtml = '<h4>ğŸ’¸ æ¶ˆè€—é“å…·</h4>';
        Object.entries(item.cost).forEach(([costItem, amount]) => {
          const owned = gameData.userItems[costItem] || 0;
          costHtml += `<div>${getItemName(costItem)}: ${amount} (å‰©é¤˜: ${owned - amount})</div>`;
        });
      }
      
      dialog.innerHTML = `
        <div class='purchase-dialog'>
          <h3>ğŸ’° è³¼è²·ç¢ºèª</h3>
          <div class="purchase-summary">
            ${rewardHtml}
          </div>
          <div class="purchase-summary">
            ${costHtml}
          </div>
          <div class="btn-group">
            <button class="square-btn" id="confirmPurchaseBtn" style="background: #4CAF50;">
              âœ… ç¢ºèª${isFree ? 'é ˜å–' : 'è³¼è²·'}
            </button>
            <button class="square-btn" onclick="closeDialog()">âŒ å–æ¶ˆ</button>
          </div>
        </div>
      `;
      
      // ç¶å®šç¢ºèªè³¼è²·äº‹ä»¶
      document.getElementById('confirmPurchaseBtn').addEventListener('click', () => {
        confirmPurchase(itemId);
      });
      
      dialog.style.display = "flex";
      document.body.style.overflow = "hidden";
    }

    // âœ… ç¢ºèªè³¼è²·
    async function confirmPurchase(itemId) {
      if (uiState.isPurchasing) return; // é˜²æ­¢é‡è¤‡è³¼è²·
      
      uiState.isPurchasing = true;
      showLoading(true);
      
      try {
        const response = await SecureAPI.post(`${API_BASE}/shop_purchase`, {
          item_id: itemId
        });
        
        const result = await response.json();
        
        if (response.ok && result.success) {
          // æ›´æ–°æœ¬åœ°æ•¸æ“š
          if (result.user_items) {
            gameData.userItems = result.user_items.items || result.user_items;
          }
          if (result.purchases) {
            gameData.userPurchases = result.purchases;
          }
          
          // æ§‹å»ºæˆåŠŸæ¶ˆæ¯
          const item = gameData.shopItems.find(i => i.id === itemId);
          let message = `âœ… è³¼è²·æˆåŠŸï¼\n\nğŸ“¦ ${item.name}`;
          
          if (result.purchase_info?.total_items_received) {
            const items = Object.entries(result.purchase_info.total_items_received)
              .map(([id, qty]) => `${getItemName(id)} x${qty}`)
              .join('\n');
            message += `\n\nç²å¾—ï¼š\n${items}`;
          }
          
          alert(message);
          
          // æ›´æ–°é¡¯ç¤º
          updateUserCurrencyDisplay();
          renderShopItems();
          closeDialog();
          
        } else {
          alert(`âŒ è³¼è²·å¤±æ•—ï¼š${result.error || result.message}`);
        }
        
      } catch (error) {
        console.error("è³¼è²·éŒ¯èª¤:", error);
        alert("âŒ è³¼è²·éç¨‹ç™¼ç”ŸéŒ¯èª¤");
      } finally {
        uiState.isPurchasing = false;
        showLoading(false);
      }
    }

    // âŒ é—œé–‰å°è©±æ¡†
    function closeDialog() {
      document.body.style.overflow = "";
      document.getElementById("dialogContainer").style.display = "none";
    }

    // ğŸ”„ åˆ†é¡ç¯©é¸
    function switchFilter(category) {
      uiState.currentFilter = category;
      
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-category="${category}"]`).classList.add('active');
      
      renderShopItems();
    }

    // ğŸš€ ä¸»åˆå§‹åŒ–å‡½æ•¸
    async function initialize() {
      showLoading(true);
      
      try {
        await loadAllData();
        
        updateUserInfoDisplay();
        updateUserCurrencyDisplay();
        renderShopItems();
        updateResetTimerDisplay();
        
        // æ¯åˆ†é˜æ›´æ–°æ™‚é–“é¡¯ç¤º
        setInterval(updateResetTimerDisplay, 60000);
        
        // ç¶å®šç¯©é¸æŒ‰éˆ•äº‹ä»¶
        document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            switchFilter(btn.dataset.category);
          });
        });
        
        console.log('ğŸª å•†åº—åˆå§‹åŒ–å®Œæˆ');
        
      } catch (error) {
        console.error("âŒ åˆå§‹åŒ–å¤±æ•—:", error);
        alert("é é¢è¼‰å…¥å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†");
      } finally {
        showLoading(false);
      }
    }

    // ğŸµ éŸ³æ¨‚æ§åˆ¶
    document.addEventListener('DOMContentLoaded', function() {
      if (window.parent && window.parent.postMessage) {
        window.parent.postMessage({ command: "switchToShopMusic" }, "*");
      }
    });

    // å…¨åŸŸå‡½æ•¸
    window.closeDialog = closeDialog;

    // ğŸ” ç™»å…¥ç‹€æ…‹ç›£è½
    onAuthStateChanged(auth, (user) => {
      if (user) {
        initialize();
      } else {
        window.parent.location.href = "/SFL/login.html";
      }
    });
  </script>
</body>
</html>
