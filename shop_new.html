<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>æ¬¡å…ƒå•†åº— 2.0</title>
  <link rel="icon" href="favicon.ico" />
  <link href="css/style.css" rel="stylesheet"/>
  <link href="css/shop.css" rel="stylesheet"/>
</head>
<body>
  <!-- è¼‰å…¥ç•«é¢ -->
  <div id="loading-placeholder"></div>
  <script src="js/loading.js"></script>
  <script>
    fetch("loadingOverlay.html")
      .then(res => res.text())
      .then(html => {
        document.getElementById("loading-placeholder").innerHTML = html;
        if (typeof startPageLoadingProgress === "function") startPageLoadingProgress();
      });
  </script>

  <h1 class="fancy-title">ğŸª æ¬¡å…ƒå•†åº— 2.0</h1>

  <!-- ç©å®¶ç‹€æ…‹å€ -->
  <div class="user-section-row">
    <div class="user-currency half">
      <h2 class="fancy-subtitle">ğŸ‘¤ ç©å®¶è³‡è¨Š</h2>
      <div id="playerInfo">
        <div class="currency-item">
          <span class="currency-name">æš±ç¨±:</span>
          <span class="currency-amount" id="playerName">è¼‰å…¥ä¸­...</span>
        </div>
        <div class="currency-item">
          <span class="currency-name">ç­‰ç´š:</span>
          <span class="currency-amount" id="playerLevel">è¼‰å…¥ä¸­...</span>
        </div>
        <div class="currency-item">
          <span class="currency-name">ä¸Šæ¬¡é€²åº—:</span>
          <span class="currency-amount" id="lastVisit">è¼‰å…¥ä¸­...</span>
        </div>
      </div>
    </div>

    <div class="user-currency half">
      <h2 class="fancy-subtitle">ğŸ’° è²¨å¹£é“å…·</h2>
      <div id="playerCurrency">è¼‰å…¥ä¸­...</div>
    </div>
  </div>

  <!-- é‡ç½®ç‹€æ…‹é¡¯ç¤º -->
  <div class="reset-timer">
    <h3>ğŸ”„ å•†åº—é‡ç½®ç‹€æ…‹</h3>
    <div id="resetStatus">
      <div class="timer-item" id="resetInfo">è¼‰å…¥ä¸­...</div>
    </div>
  </div>

  <!-- å•†å“åˆ†é¡ç¯©é¸ -->
  <div class="shop-filters">
    <button class="filter-btn active" data-category="all">
      ğŸ›ï¸ å…¨éƒ¨å•†å“ <span class="category-count" id="count-all">0</span>
    </button>
    <button class="filter-btn" data-category="free">
      ğŸ å…è²»å•†å“ <span class="category-count" id="count-free">0</span>
    </button>
    <button class="filter-btn" data-category="limited">
      â° é™æ™‚å•†å“ <span class="category-count" id="count-limited">0</span>
    </button>
    <button class="filter-btn" data-category="unlimited">
      â™¾ï¸ ç„¡é™å•†å“ <span class="category-count" id="count-unlimited">0</span>
    </button>
    <button class="filter-btn" data-category="special">
      â­ ç‰¹æ®Šå•†å“ <span class="category-count" id="count-special">0</span>
    </button>
  </div>

  <!-- å•†å“åˆ—è¡¨ -->
  <div class="items-section">
    <div class="item-grid" id="shopGrid">è¼‰å…¥ä¸­...</div>
  </div>

  <!-- è³¼è²·å°è©±æ¡† -->
  <div id="purchaseDialog" class="dialog-overlay" style="display: none;">
    <div class="purchase-dialog">
      <h3>ğŸ›’ è³¼è²·ç¢ºèª</h3>
      <div id="dialogContent">è¼‰å…¥ä¸­...</div>
      <div class="btn-group">
        <button id="confirmBtn" class="square-btn" style="background: #4CAF50;">âœ… ç¢ºèª</button>
        <button id="cancelBtn" class="square-btn" style="background: #f44336;">âŒ å–æ¶ˆ</button>
      </div>
    </div>
  </div>

  <!-- è¼‰å…¥æŒ‡ç¤ºå™¨ -->
  <div id="loadingIndicator" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 10000;">
    <div style="text-align: center;">
      <div style="margin-bottom: 10px;">â³</div>
      <div>è™•ç†ä¸­...</div>
    </div>
  </div>

  <script type="module">
    import { auth, SecureAPI } from "./js/firebase-init.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    const API_BASE = "https://sfl-9cb8.onrender.com";
    
    // ğŸª å•†åº—ç‹€æ…‹ç®¡ç†
    class ShopManager {
      constructor() {
        this.shopData = {
          items: [],
          playerData: {},
          playerItems: {},
          shopStatus: {},
          itemMeta: {}
        };
        this.ui = {
          currentFilter: 'all',
          purchasing: false
        };
      }

      // ğŸ”„ åˆå§‹åŒ–å•†åº—
      async initialize() {
        try {
          this.showLoading(true);
          await this.loadAllData();
          this.renderAll();
          this.bindEvents();
          console.log('ğŸª å•†åº—åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
          console.error('âŒ å•†åº—åˆå§‹åŒ–å¤±æ•—:', error);
          this.showError('å•†åº—è¼‰å…¥å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢');
        } finally {
          this.showLoading(false);
        }
      }

      // ğŸ“Š è¼‰å…¥æ‰€æœ‰è³‡æ–™
      async loadAllData() {
        const [shopItems, playerRes, itemsRes, shopStatusRes] = await Promise.all([
          fetch("parameter/shop_items.json").then(r => r.json()),
          SecureAPI.getStatus(false).then(r => r.json()),
          SecureAPI.getStaticData('items_table'),
          fetch(`${API_BASE}/shop_status`, {
            headers: await this.getAuthHeaders()
          }).then(r => r.json())
        ]);

        this.shopData.items = shopItems;
        this.shopData.playerData = playerRes;
        this.shopData.itemMeta = Array.isArray(itemsRes) 
          ? itemsRes.reduce((acc, item) => ({ ...acc, [item.id]: item }), {})
          : itemsRes;
        this.shopData.shopStatus = shopStatusRes;

        // è¼‰å…¥ç©å®¶é“å…·
        const itemsResponse = await SecureAPI.get(`${API_BASE}/user_items`, false);
        if (itemsResponse.ok) {
          const itemsData = await itemsResponse.json();
          this.shopData.playerItems = itemsData.items || {};
        }
      }

      // ğŸ¨ æ¸²æŸ“æ‰€æœ‰ä»‹é¢
      renderAll() {
        this.renderPlayerInfo();
        this.renderPlayerCurrency();
        this.renderResetStatus();
        this.renderShopItems();
        this.updateCategoryCounts();
      }

      // ğŸ‘¤ æ¸²æŸ“ç©å®¶è³‡è¨Š
      renderPlayerInfo() {
        const { playerData, shopStatus } = this.shopData;
        
        document.getElementById('playerName').textContent = playerData.nickname || 'æœªçŸ¥ç©å®¶';
        document.getElementById('playerLevel').textContent = `Lv.${playerData.level || 1}`;
        
        const lastVisit = shopStatus.last_visit_time 
          ? new Date(shopStatus.last_visit_time * 1000).toLocaleString('zh-TW')
          : 'é¦–æ¬¡é€²åº—';
        document.getElementById('lastVisit').textContent = lastVisit;
      }

      // ğŸ’° æ¸²æŸ“ç©å®¶è²¨å¹£
      renderPlayerCurrency() {
        const currencies = ['world_boss_token', 'daily_coin', 'chaos_breath'];
        let html = '';
        
        currencies.forEach(currencyId => {
          const meta = this.shopData.itemMeta[currencyId];
          const amount = this.shopData.playerItems[currencyId] || 0;
          const name = meta?.name || currencyId;
          
          html += `
            <div class="currency-item">
              <span class="currency-name">${name}:</span>
              <span class="currency-amount">${amount}</span>
            </div>
          `;
        });
        
        document.getElementById('playerCurrency').innerHTML = html;
      }

      // ğŸ”„ æ¸²æŸ“é‡ç½®ç‹€æ…‹
      renderResetStatus() {
        const { shopStatus } = this.shopData;
        let statusHtml = '';

        if (shopStatus.reset_performed) {
          const resets = [];
          if (shopStatus.reset_performed.daily) resets.push('æ¯æ—¥');
          if (shopStatus.reset_performed.weekly) resets.push('æ¯é€±');
          if (shopStatus.reset_performed.monthly) resets.push('æ¯æœˆ');
          
          if (resets.length > 0) {
            statusHtml = `ğŸ”„ å·²åŸ·è¡Œé‡ç½®: ${resets.join('ã€')}`;
          } else {
            statusHtml = 'âœ… ç„¡éœ€é‡ç½®';
          }
        } else {
          statusHtml = 'âœ… å•†åº—ç‹€æ…‹æ­£å¸¸';
        }

        document.getElementById('resetInfo').innerHTML = statusHtml;
      }

      // ğŸ›ï¸ æ¸²æŸ“å•†å“åˆ—è¡¨
      renderShopItems() {
        const { items, shopStatus } = this.shopData;
        
        // ç¯©é¸å•†å“
        let filteredItems = items;
        if (this.ui.currentFilter !== 'all') {
          filteredItems = items.filter(item => this.getItemCategory(item) === this.ui.currentFilter);
        }

        // æ’åºå•†å“
        filteredItems.sort((a, b) => {
          const aCanBuy = this.canPurchaseItem(a).canPurchase;
          const bCanBuy = this.canPurchaseItem(b).canPurchase;
          if (aCanBuy !== bCanBuy) return bCanBuy ? -1 : 1;
          return (a.sort || 999) - (b.sort || 999);
        });

        let html = '';
        filteredItems.forEach(item => {
          html += this.renderShopItem(item);
        });

        document.getElementById('shopGrid').innerHTML = html || 
          '<div class="shop-item-card">æ­¤åˆ†é¡æš«ç„¡å•†å“</div>';
      }

      // ğŸ¯ æ¸²æŸ“å–®å€‹å•†å“
      renderShopItem(item) {
        const { canPurchase, reason } = this.canPurchaseItem(item);
        const purchases = this.shopData.shopStatus.purchases?.[item.id] || {};
        
        // æ±ºå®šå¡ç‰‡æ¨£å¼
        let cardClasses = ['shop-item-card'];
        if (!canPurchase) cardClasses.push('sold-out');
        if (this.isFreeItem(item)) cardClasses.push('free');
        if (item.type === 'bundle') cardClasses.push('bundle');
        
        // å•†å“æ¨™é¡Œ
        const specialLabel = this.getSpecialLabel(item);
        const title = `${specialLabel}${item.name}`;

        // ç²å¾—ç‰©å“é¡¯ç¤º
        const rewardHtml = this.renderItemRewards(item);

        // æ¶ˆè²»é¡¯ç¤º
        const costHtml = this.renderItemCost(item);

        // è³¼è²·é™åˆ¶é¡¯ç¤º
        const limitHtml = this.renderItemLimits(item, purchases);

        // è³¼è²·æŒ‰éˆ•
        const buttonHtml = canPurchase 
          ? `<button class="square-btn purchase-btn" data-item-id="${item.id}">
              ${this.isFreeItem(item) ? 'ğŸ é ˜å–' : 'ğŸ’° è³¼è²·'}
             </button>`
          : `<div class="error-message">âŒ ${reason}</div>`;

        return `
          <div class="${cardClasses.join(' ')}">
            <div class="shop-item-name">${title}</div>
            <div class="shop-item-desc">${item.description}</div>
            ${rewardHtml}
            ${limitHtml}
            ${costHtml}
            ${buttonHtml}
          </div>
        `;
      }

      // ğŸ æ¸²æŸ“å•†å“çå‹µ
      renderItemRewards(item) {
        if (item.type === 'bundle' && item.items) {
          const itemList = item.items
            .map(i => `${this.getItemName(i.item_id)} x${i.quantity}`)
            .join('ã€');
          return `<div class="shop-item-desc">ğŸ“¦ ç²å¾—ï¼š${itemList}</div>`;
        } else if (item.item_id) {
          return `<div class="shop-item-desc">ğŸ“¦ ç²å¾—ï¼š${this.getItemName(item.item_id)} x${item.quantity}</div>`;
        }
        return '';
      }

      // ğŸ’¸ æ¸²æŸ“å•†å“è²»ç”¨
      renderItemCost(item) {
        if (this.isFreeItem(item)) {
          return '<div style="color: #4CAF50; text-align: center; margin: 10px 0;">ğŸ’° å…è²»</div>';
        }

        let html = '<div class="shop-item-cost">';
        Object.entries(item.cost).forEach(([costItem, amount]) => {
          const owned = this.shopData.playerItems[costItem] || 0;
          const sufficient = owned >= amount;
          html += `
            <div class="cost-item">
              <span class="cost-name">${this.getItemName(costItem)}:</span>
              <div>
                <span class="cost-amount">${amount}</span>
                <span class="cost-owned ${sufficient ? '' : 'cost-insufficient'}">(æœ‰: ${owned})</span>
              </div>
            </div>
          `;
        });
        html += '</div>';
        return html;
      }

      // ğŸ“Š æ¸²æŸ“è³¼è²·é™åˆ¶
      renderItemLimits(item, purchases) {
        let limits = [];

        if (item.limit_per_account > 0) {
          const total = purchases.total_purchased || 0;
          limits.push(`ç¸½è¨ˆ: ${total}/${item.limit_per_account}`);
        }

        if (item.reset_type !== 'none' && item.limit_per_reset > 0) {
          const resetKey = `${item.reset_type}_purchased`;
          const purchased = purchases[resetKey] || 0;
          const typeName = { daily: 'ä»Šæ—¥', weekly: 'æœ¬é€±', monthly: 'æœ¬æœˆ' }[item.reset_type];
          limits.push(`${typeName}: ${purchased}/${item.limit_per_reset}`);
        }

        if (item.limit_per_reset === -1) {
          limits.push('â™¾ï¸ ç„¡é™è³¼è²·');
        }

        return limits.length > 0 
          ? `<div class="shop-item-limit">${limits.join(' | ')}</div>`
          : '';
      }

      // âœ… æª¢æŸ¥æ˜¯å¦å¯è³¼è²·
      canPurchaseItem(item) {
        const purchases = this.shopData.shopStatus.purchases?.[item.id] || {};
        const playerLevel = this.shopData.playerData.level || 1;

        // æª¢æŸ¥ç­‰ç´šé™åˆ¶
        if (playerLevel < (item.required_level || 1)) {
          return {
            canPurchase: false,
            reason: `ç­‰ç´šä¸è¶³ (éœ€è¦Lv.${item.required_level}ï¼Œç›®å‰Lv.${playerLevel})`
          };
        }

        // æª¢æŸ¥ç¸½è³¼è²·é™åˆ¶
        if (item.limit_per_account > 0 && 
            (purchases.total_purchased || 0) >= item.limit_per_account) {
          return { canPurchase: false, reason: 'å·²é”ç¸½è³¼è²·ä¸Šé™' };
        }

        // æª¢æŸ¥é€±æœŸè³¼è²·é™åˆ¶
        if (item.reset_type !== 'none' && item.limit_per_reset > 0) {
          const resetKey = `${item.reset_type}_purchased`;
          if ((purchases[resetKey] || 0) >= item.limit_per_reset) {
            const typeName = { daily: 'ä»Šæ—¥', weekly: 'æœ¬é€±', monthly: 'æœ¬æœˆ' }[item.reset_type];
            return { canPurchase: false, reason: `å·²é”${typeName}è³¼è²·ä¸Šé™` };
          }
        }

        // æª¢æŸ¥è²¨å¹£æ˜¯å¦è¶³å¤ 
        if (!this.isFreeItem(item)) {
          for (const [costItem, costAmount] of Object.entries(item.cost)) {
            const owned = this.shopData.playerItems[costItem] || 0;
            if (owned < costAmount) {
              return { 
                canPurchase: false, 
                reason: `${this.getItemName(costItem)} ä¸è¶³` 
              };
            }
          }
        }

        return { canPurchase: true };
      }

      // ğŸ”„ æ›´æ–°åˆ†é¡è¨ˆæ•¸
      updateCategoryCounts() {
        const categories = ['all', 'free', 'limited', 'unlimited', 'special'];
        const items = this.shopData.items;
        
        categories.forEach(category => {
          let count;
          if (category === 'all') {
            count = items.length;
          } else {
            count = items.filter(item => this.getItemCategory(item) === category).length;
          }
          
          const countEl = document.getElementById(`count-${category}`);
          if (countEl) countEl.textContent = count;
        });
      }

      // ğŸ·ï¸ ç²å–å•†å“åˆ†é¡
      getItemCategory(item) {
        if (this.isFreeItem(item)) return 'free';
        if (item.limit_per_reset === -1) return 'unlimited';
        if (item.reset_type !== 'none') return 'limited';
        if (item.special > 0) return 'special';
        return 'normal';
      }

      // ğŸ¯ å·¥å…·æ–¹æ³•
      isFreeItem(item) {
        return !item.cost || Object.keys(item.cost).length === 0;
      }

      getItemName(itemId) {
        return this.shopData.itemMeta[itemId]?.name || itemId;
      }

      getSpecialLabel(item) {
        const labels = { 1: 'ã€ç¨€æœ‰ã€‘', 2: 'ã€è¶…ç¨€æœ‰ã€‘', 3: 'ã€ç½•è¦‹ã€‘' };
        return labels[item.special] || '';
      }

      async getAuthHeaders() {
        const user = auth.currentUser;
        if (!user) throw new Error('æœªç™»å…¥');
        const token = await user.getIdToken();
        return {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        };
      }

      // ğŸ›’ è³¼è²·æµç¨‹
      async openPurchaseDialog(itemId) {
        const item = this.shopData.items.find(i => i.id === itemId);
        if (!item) return;

        const { canPurchase, reason } = this.canPurchaseItem(item);
        if (!canPurchase) {
          alert(`ç„¡æ³•è³¼è²·ï¼š${reason}`);
          return;
        }

        // æ¸²æŸ“å°è©±æ¡†å…§å®¹
        const rewardHtml = this.renderItemRewards(item);
        const costHtml = this.renderItemCost(item);
        
        document.getElementById('dialogContent').innerHTML = `
          <div style="margin-bottom: 15px;">
            <strong>${item.name}</strong>
          </div>
          ${rewardHtml}
          ${costHtml}
        `;

        // é¡¯ç¤ºå°è©±æ¡†
        document.getElementById('purchaseDialog').style.display = 'flex';
        document.body.style.overflow = 'hidden';

        // ç¶å®šç¢ºèªæŒ‰éˆ•
        document.getElementById('confirmBtn').onclick = () => this.confirmPurchase(itemId);
      }

      async confirmPurchase(itemId) {
        if (this.ui.purchasing) return;
        
        this.ui.purchasing = true;
        this.showLoading(true);

        try {
          const response = await fetch(`${API_BASE}/shop_purchase_new`, {
            method: 'POST',
            headers: await this.getAuthHeaders(),
            body: JSON.stringify({ item_id: itemId })
          });

          const result = await response.json();

          if (response.ok && result.success) {
            // æ›´æ–°æœ¬åœ°è³‡æ–™
            if (result.player_items) {
              this.shopData.playerItems = result.player_items;
            }
            if (result.shop_status) {
              this.shopData.shopStatus = result.shop_status;
            }

            // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
            const item = this.shopData.items.find(i => i.id === itemId);
            alert(`âœ… è³¼è²·æˆåŠŸï¼\n\n${item.name}`);

            // é‡æ–°æ¸²æŸ“
            this.renderAll();
            this.closePurchaseDialog();

          } else {
            alert(`âŒ è³¼è²·å¤±æ•—ï¼š${result.error || result.message || 'æœªçŸ¥éŒ¯èª¤'}`);
          }

        } catch (error) {
          console.error('è³¼è²·éŒ¯èª¤:', error);
          alert('âŒ è³¼è²·éç¨‹ç™¼ç”ŸéŒ¯èª¤');
        } finally {
          this.ui.purchasing = false;
          this.showLoading(false);
        }
      }

      closePurchaseDialog() {
        document.getElementById('purchaseDialog').style.display = 'none';
        document.body.style.overflow = '';
      }

      // ğŸ¯ UI å·¥å…·æ–¹æ³•
      showLoading(show) {
        const loading = document.getElementById("loadingOverlay");
        const indicator = document.getElementById("loadingIndicator");
        if (loading) loading.style.display = show ? "flex" : "none";
        if (indicator) indicator.style.display = show ? "block" : "none";
      }

      showError(message) {
        alert(message);
      }

      // ğŸ”— ç¶å®šäº‹ä»¶
      bindEvents() {
        // åˆ†é¡ç¯©é¸
        document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            this.ui.currentFilter = btn.dataset.category;
            
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            this.renderShopItems();
            this.updateCategoryCounts();
          });
        });

        // è³¼è²·æŒ‰éˆ•ï¼ˆäº‹ä»¶å§”æ´¾ï¼‰
        document.getElementById('shopGrid').addEventListener('click', (e) => {
          if (e.target.classList.contains('purchase-btn')) {
            e.preventDefault();
            this.openPurchaseDialog(e.target.dataset.itemId);
          }
        });

        // å°è©±æ¡†å–æ¶ˆæŒ‰éˆ•
        document.getElementById('cancelBtn').addEventListener('click', () => {
          this.closePurchaseDialog();
        });

        // å°è©±æ¡†èƒŒæ™¯é»æ“Šé—œé–‰
        document.getElementById('purchaseDialog').addEventListener('click', (e) => {
          if (e.target === e.currentTarget) {
            this.closePurchaseDialog();
          }
        });
      }
    }

    // ğŸš€ å…¨åŸŸåˆå§‹åŒ–
    const shopManager = new ShopManager();

    // ğŸµ éŸ³æ¨‚æ§åˆ¶
    if (window.parent?.postMessage) {
      window.parent.postMessage({ command: "switchToShopMusic" }, "*");
    }

    // ğŸ” èªè­‰ç‹€æ…‹ç›£è½
    onAuthStateChanged(auth, (user) => {
      if (user) {
        shopManager.initialize();
      } else {
        window.parent.location.href = "/SFL/login.html";
      }
    });
  </script>

  <style>
    .dialog-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .purchase-dialog {
      background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(25, 25, 55, 0.95) 100%);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(0, 255, 255, 0.3);
      border-radius: 20px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .btn-group .square-btn {
      flex: 1;
    }

    .error-message {
      color: #ff6b6b;
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      background: rgba(255, 107, 107, 0.1);
      border: 1px solid rgba(255, 107, 107, 0.3);
      border-radius: 8px;
    }

    .purchase-btn {
      width: 100%;
      margin-top: 10px;
    }
  </style>
</body>
</html>
