<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>èƒŒåŒ…èˆ‡è£å‚™ç®¡ç†</title>
  <link rel="icon" href="favicon.ico" />
  <link href="css/inventory.css" rel="stylesheet"/>
  
  <!-- ğŸ†• å‰¯æœ¬ä¸‹æ‹‰é¸å–®å…§è¯æ¨£å¼ -->
  <style>
    /* ç¢ºä¿åˆ†é¡æŒ‰éˆ•å®¹å™¨æ”¯æ´çµ•å°å®šä½ */
    .item-category-buttons {
      position: relative !important;
    }
    
    /* å‰¯æœ¬åˆ†é¡ä¸‹æ‹‰é¸å–® */
    .dropdown-btn #dropdown-arrow {
      margin-left: 5px;
      transition: transform 0.3s ease;
    }

    .dropdown-btn.expanded #dropdown-arrow {
      transform: rotate(180deg);
    }

    .dungeon-dropdown {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(25, 25, 55, 0.95) 100%);
      backdrop-filter: blur(15px);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 15px;
      padding: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      /* ğŸ”§ ä¿®å¾©ï¼šé è¨­å®Œå…¨éš±è— */
      display: none !important;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
      min-width: 200px;
      visibility: hidden;
      opacity: 0;
      transition: all 0.3s ease;
    }

    .dungeon-dropdown.show {
      /* ğŸ”§ ä¿®å¾©ï¼šå¼·åˆ¶é¡¯ç¤ºï¼Œè¦†è“‹é è¨­éš±è— */
      display: flex !important;
      visibility: visible !important;
      opacity: 1 !important;
    }

    .dungeon-btn {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 119, 198, 0.05) 100%);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 10px;
      padding: 8px 12px;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.85em;
      text-align: left;
    }

    .dungeon-btn:hover {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(255, 119, 198, 0.1) 100%);
      border-color: rgba(0, 255, 255, 0.4);
      transform: translateX(3px);
    }

    .dungeon-btn.active {
      background: linear-gradient(135deg, #00ffff 0%, #00bfff 100%);
      color: #000;
      border-color: #00ffff;
      font-weight: 700;
    }

    /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
    @media (max-width: 768px) {
      .dungeon-dropdown {
        left: 10px;
        right: 10px;
        transform: none;
        width: auto;
        min-width: auto;
      }
    }
  </style>
</head>
<body>
  <div id="initialOverlay">è¼‰å…¥ä¸­...</div>
  <div id="loading-placeholder"></div>
  <script src="js/loading.js"></script>
  <script>
    fetch("loadingOverlay.html")
      .then(res => res.text())
      .then(html => {
        document.getElementById("loading-placeholder").innerHTML = html;
        document.getElementById("initialOverlay")?.remove();
        if (typeof startPageLoadingProgress === "function") startPageLoadingProgress();
      });
  </script>

  <h1 class="fancy-title">ğŸŒŒ å¡ç‰‡çŸ©é™£ç³»çµ±</h1>
  <div class="top-grid">
    <div class="stats-section">
      <h2 class="fancy-subtitle">ğŸ§¬ è§’è‰²å±¬æ€§</h2>
      <div id="statsDisplay"></div>
    </div>
    
    <div class="equipment-section">
      <h2 class="fancy-subtitle">ğŸ“ å¡ç‰‡æ’æ§½</h2>
      <div id="equipmentDisplay"></div>
    </div>
  </div>
  
  <div class="btn-group">
    <button class="square-btn" onclick="openCraftUI()">ğŸ’» è£½ä½œçµ‚ç«¯</button>
    <button class="square-btn" onclick="openEquipUI()">ğŸ›°ï¸ æ’æ§½ç®¡ç†</button>
  </div>
  
  <div class="items-section">
    <h2 class="fancy-subtitle">ğŸ“¦ æŒæœ‰é“å…·</h2>
    
    <!-- ğŸ†• é“å…·åˆ†é¡æŒ‰éˆ• -->
    <div class="item-category-buttons">
      <button class="category-btn active" data-category="all" onclick="filterItems('all')">å…¨éƒ¨</button>
      <button class="category-btn" data-category="1" onclick="filterItems(1)">ç¨€æœ‰</button>
      <button class="category-btn" data-category="2" onclick="filterItems(2)">è¶…ç¨€æœ‰</button>
      <button class="category-btn" data-category="3" onclick="filterItems(3)">ç½•è¦‹</button>
      <button class="category-btn dropdown-btn" data-category="dungeon" onclick="toggleDungeonDropdown()">
        å‰¯æœ¬åˆ†é¡ <span id="dropdown-arrow">â–¼</span>
      </button>
    </div>
    
    <!-- ğŸ†• å‰¯æœ¬åˆ†é¡ä¸‹æ‹‰é¸å–® -->
    <div class="dungeon-dropdown" id="dungeonDropdown">
      <button class="dungeon-btn" data-belong="1" onclick="filterItems('dungeon_1')">è…çˆ›æ²¼æ¾¤åœ°</button>
      <button class="dungeon-btn" data-belong="2" onclick="filterItems('dungeon_2')">å¤©ç©ºä¹‹åŸ</button>
      <button class="dungeon-btn" data-belong="3" onclick="filterItems('dungeon_3')">é‹¼éµéƒ½å¸‚</button>
      <button class="dungeon-btn" data-belong="4" onclick="filterItems('dungeon_4')">ç´«é­”ä¹‹åŸ</button>
      <button class="dungeon-btn" data-belong="5" onclick="filterItems('dungeon_5')">å¤¢é­˜å¹»å¢ƒ</button>
      <button class="dungeon-btn" data-belong="7" onclick="filterItems('dungeon_7')">ç¬¬ä¸€è¦å¡</button>
      <button class="dungeon-btn" data-belong="8" onclick="filterItems('dungeon_8')">ç¬¬äºŒè¦å¡</button>
    </div>
    
    <!-- ğŸ†• åˆ†é¡çµ±è¨ˆé¡¯ç¤º -->
    <div class="category-stats" id="categoryStats">è¼‰å…¥ä¸­...</div>
    
    <div class="item-grid" id="itemGrid"></div>
  </div>
  
  <div id="dialogContainer"></div>
  <div id="loadingSpinner" class="loading-spinner">è™•ç†ä¸­...</div>

  <script type="module">
    import { auth, SecureAPI, PerformanceMonitor } from "./js/firebase-init.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    const API_BASE = "https://sfl-9cb8.onrender.com";
    let userData = {};
    let userItems = {};
    let equipData = [];
    let itemMeta = [];
    let cardData = [];
    let userCards = {};
    let cardFailureCounts = {};
    
    // ğŸ†• é“å…·åˆ†é¡ç‹€æ…‹
    let currentCategory = 'all';
    let isDungeonDropdownOpen = false;

    // ğŸ†• å‰¯æœ¬åç¨±æ˜ å°„
    const dungeonNames = {
      1: "è…çˆ›æ²¼æ¾¤åœ°",
      2: "å¤©ç©ºä¹‹åŸ", 
      3: "é‹¼éµéƒ½å¸‚",
      4: "ç´«é­”ä¹‹åŸ",
      5: "å¤¢é­˜å¹»å¢ƒ",
      6: "è–å¤©æ•™æœƒ", // é›–ç„¶æŒ‰éˆ•ä¸­æ²’æœ‰ï¼Œä½†æ•¸æ“šä¸­å­˜åœ¨
      7: "ç¬¬ä¸€è¦å¡",
      8: "ç¬¬äºŒè¦å¡"
    };

    function showLoading(show) {
      const loading = document.getElementById("loadingOverlay");
      const spinner = document.getElementById("loadingSpinner");
      if (loading) loading.style.display = show ? "flex" : "none";
      if (spinner) spinner.style.display = show ? "block" : "none";
    }

    // éŠæˆ²è³‡æ–™è¼‰å…¥
    async function loadGameData() {
      PerformanceMonitor.startTiming('loadGameData');
      
      try {
        // ä¸¦è¡Œè¼‰å…¥æ‰€æœ‰éœæ…‹è³‡æ–™ï¼Œä½¿ç”¨å¿«å–
        const [equipRes, itemRes, cardRes] = await Promise.all([
          SecureAPI.getStaticData('equips_table'),
          SecureAPI.getStaticData('items_table'), 
          SecureAPI.getStaticData('cards_data')
        ]);
        
        equipData = Array.isArray(equipRes) ? equipRes : Object.values(equipRes);
        
        // è™•ç† items è³‡æ–™æ ¼å¼
        if (Array.isArray(itemRes)) {
          itemMeta = itemRes;
        } else if (typeof itemRes === 'object') {
          itemMeta = Object.values(itemRes);
        } else {
          throw new Error('ç„¡æ•ˆçš„é“å…·è³‡æ–™æ ¼å¼');
        }
        
        // ğŸš€ ç¢ºä¿æ¯å€‹é“å…·éƒ½æœ‰ belong å’Œ sort æ¬„ä½
        itemMeta = itemMeta.map(item => ({
          ...item,
          belong: item.belong || 0,
          sort: item.sort || 0
        }));
        
        console.log(`ğŸ“¦ è¼‰å…¥äº† ${itemMeta.length} å€‹é“å…·è³‡æ–™`);
        console.log(`ğŸ·ï¸ å‰¯æœ¬åˆ†é¡çµ±è¨ˆ:`, itemMeta.reduce((acc, item) => {
          const belong = item.belong || 0;
          acc[belong] = (acc[belong] || 0) + 1;
          return acc;
        }, {}));
        
        // cardData
        try {
          const cardResponse = await fetch("parameter/cards_data.json");
          cardData = await cardResponse.json();
        } catch (error) {
          console.warn('è¼‰å…¥å¡ç‰‡è³‡æ–™å¤±æ•—ï¼Œä½¿ç”¨ç©ºé™£åˆ—:', error);
          cardData = [];
        }
        
      } catch (error) {
        console.error("è¼‰å…¥éŠæˆ²è³‡æ–™å¤±æ•—:", error);
        alert("è¼‰å…¥éŠæˆ²è³‡æ–™å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢");
        throw error;
      } finally {
        PerformanceMonitor.endTiming('loadGameData');
      }
    }

    async function loadCardFailureCounts() {
      try {
        const response = await SecureAPI.get(`${API_BASE}/card_failure_counts`, true);
        if (response && response.ok) {
          cardFailureCounts = await response.json();
        } else {
          cardFailureCounts = {};
        }
      } catch (error) {
        console.error("è¼‰å…¥å¡ç‰‡å¤±æ•—æ¬¡æ•¸å¤±æ•—:", error);
        cardFailureCounts = {};
      }
    }

    function calculateEnhancedSuccessRate(baseRate, failureCount) {
      const enhancedRate = baseRate + (failureCount * 0.05);
      return Math.min(enhancedRate, 1.0); // æœ€é«˜100%
    }

    // æ ¼å¼åŒ–æˆåŠŸç‡é¡¯ç¤º
    function formatSuccessRateDisplay(baseRate, failureCount) {
      const enhancedRate = calculateEnhancedSuccessRate(baseRate, failureCount);
      const enhancedPercentage = (enhancedRate * 100).toFixed(0);
      const bonusPercentage = failureCount * 5;
      
      let html = `<span class="craft-success-rate">æˆåŠŸç‡: `;
      
      if (enhancedRate >= 1.0) {
        // 100% å¿…å®šæˆåŠŸ
        html += `<span class="guaranteed-success">å¿…å®šæˆåŠŸ ${enhancedPercentage}%</span>`;
      } else {
        html += `${enhancedPercentage}%`;
      }
      
      if (failureCount > 0) {
        html += ` <span class="failure-bonus">(å¤±æ•—åŠ æˆ ${failureCount} æ¬¡ï¼šæˆåŠŸç‡å¢åŠ  ${bonusPercentage}%)</span>`;
      }
      
      html += `</span>`;
      return html;
    }

    async function loadUserData(forceRefresh = true) {
      PerformanceMonitor.startTiming('loadUserData');
      
      try {
        console.log(`ğŸ”„ è¼‰å…¥ä½¿ç”¨è€…è³‡æ–™ ${forceRefresh ? '(å¼·åˆ¶åˆ·æ–°)' : '(å…è¨±å¿«å–)'}`);
        
        // ğŸ¯ å¼·åˆ¶å¾ä¼ºæœå™¨é‡æ–°ç²å–è³‡æ–™
        const promises = [
          SecureAPI.getStatus(forceRefresh),
          SecureAPI.get(`${API_BASE}/user_items`, !forceRefresh), // å¦‚æœforceRefresh=trueï¼Œå‰‡useCache=false
          SecureAPI.get(`${API_BASE}/user_cards`, !forceRefresh)
        ];
        
        const [statusRes, itemsRes, cardsRes] = await Promise.all(promises);
        
        // è™•ç†ä½¿ç”¨è€…ç‹€æ…‹
        userData = await statusRes.json();
        
        // è™•ç†ä½¿ç”¨è€…é“å…·
        if (itemsRes && itemsRes.ok) {
          userItems = await itemsRes.json();
        } else {
          userItems = userData.items || {};
        }
        
        // è™•ç†ä½¿ç”¨è€…å¡ç‰‡
        if (cardsRes && cardsRes.ok) {
          userCards = await cardsRes.json();
        } else {
          userCards = userData.cards_owned || {};
        }
        
        // é©—è­‰è£å‚™ç­‰ç´šä¸ä¸€è‡´å•é¡Œ
        await validateAndFixEquipmentLevels();
        
        renderPage();

      } catch (error) {
        console.error("è¼‰å…¥ä½¿ç”¨è€…è³‡æ–™å¤±æ•—:", error);
        
        // å¦‚æœè¼‰å…¥å¤±æ•—ï¼Œå˜—è©¦é‡æ–°è¼‰å…¥ä½†å…è¨±å¿«å–
        if (forceRefresh) {
          console.log("ğŸ”„ å¼·åˆ¶è¼‰å…¥å¤±æ•—ï¼Œå˜—è©¦ä½¿ç”¨å¿«å–è³‡æ–™...");
          try {
            await loadUserData(false);
          } catch (fallbackError) {
            console.error("é€£å¿«å–è¼‰å…¥ä¹Ÿå¤±æ•—:", fallbackError);
            alert("è¼‰å…¥ä½¿ç”¨è€…è³‡æ–™å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢");
          }
        } else {
          alert("è¼‰å…¥ä½¿ç”¨è€…è³‡æ–™å¤±æ•—");
          throw error;
        }
      } finally {
        PerformanceMonitor.endTiming('loadUserData');
      }
    }

    function calculateEquipmentBonus() {
      const bonus = {};
      const equipment = userData.equipment || {};
      
      for (let slot = 1; slot <= 5; slot++) {
        const equippedCard = equipment[slot];
        if (!equippedCard) continue;
        
        const cardId = Object.keys(equippedCard)[0];
        const cardLevel = equippedCard[cardId];
        const equipInfo = equipData.find(e => e.id === cardId);
        
        if (equipInfo && equipInfo.value && equipInfo.value[cardLevel]) {
          const cardStats = equipInfo.value[cardLevel];
          for (const [stat, value] of Object.entries(cardStats)) {
            bonus[stat] = (bonus[stat] || 0) + value;
          }
        }
      }
      
      return bonus;
    }

    function renderStats() {
      const baseStats = userData.base_stats || {};
      const equipBonus = calculateEquipmentBonus(userData.equipment || {}, equipData);
      const statsEl = document.getElementById("statsDisplay");
      
      const statsList = [
        { key: "hp", label: "ç”Ÿå‘½å€¼", isPercent: false },
        { key: "attack", label: "æ”»æ“ŠåŠ›", isPercent: false },
        { key: "shield", label: "è­·ç›¾å€¼", isPercent: false },
        { key: "evade", label: "è¿´é¿ç‡", isPercent: true },
        { key: "accuracy", label: "å‘½ä¸­ç‡", isPercent: true },
        { key: "other_bonus", label: "é¡å¤–å‚·å®³åŠ æˆ", isPercent: true },
        { key: "luck", label: "å¹¸é‹å€¼", isPercent: false },
        { key: "atk_speed", label: "æ”»æ“Šé€Ÿåº¦", isPercent: false },
        { key: "penetrate", label: "è­·ç›¾ç©¿é€", isPercent: false }
      ];
      
      let html = "";
      statsList.forEach(({ key, label, isPercent }) => {
        const base = baseStats[key] || 0;
        const bonus = equipBonus[key] || 0;
        const total = base + bonus;
        
        const displayValue = isPercent ? `${(total * 100).toFixed(1)}%` : total;
        const bonusDisplay = bonus > 0 ? ` (+${isPercent ? (bonus * 100).toFixed(1) + '%' : bonus})` : '';
        
        html += `
          <div class="stat-item">
            <span>${label}:</span>
            <span>${displayValue} (${isPercent ? (base * 100).toFixed(1) + '%' : base}${bonusDisplay})</span>
          </div>
        `;
      });
      
      statsEl.innerHTML = html;
    }

    function renderEquipment() {
      const equipment = userData.equipment || {};
      const equipEl = document.getElementById("equipmentDisplay");
      
      let html = "";
      for (let slot = 1; slot <= 5; slot++) {
        const equippedCard = equipment[slot];
        
        if (!equippedCard) {
          html += `
            <div class="equipment-slot empty">
              æ¬„ä½ ${slot}: ç„¡è£å‚™
            </div>
          `;
        } else {
          const cardId = Object.keys(equippedCard)[0];
          const cardLevel = equippedCard[cardId];
          const equipInfo = equipData.find(e => e.id === cardId);
    
          const statNameMap = {
            hp: "ç”Ÿå‘½å€¼",
            attack: "æ”»æ“ŠåŠ›",
            shield: "è­·ç›¾",
            evade: "é–ƒé¿",
            accuracy: "å‘½ä¸­",
            luck: "é‹æ°£",
            atk_speed: "æ”»æ“Šé€Ÿåº¦",
            other_bonus: "å…¶ä»–åŠ æˆ"
          };
    
          if (equipInfo && equipInfo.value && equipInfo.value[cardLevel]) {
            const stats = equipInfo.value[cardLevel]; 
            const statsText = Object.entries(stats)
              .map(([key, value]) => {
                const label = statNameMap[key] || key;
                const displayValue = ['evade','accuracy','other_bonus'].includes(key)
                  ? `+${(value * 100).toFixed(1)}%`
                  : `+${value}`;
                return `${label}: ${displayValue}`;
              })
              .join(", ");
              
            html += `
              <div class="equipment-slot">
                <strong>æ¬„ä½ ${slot}: ${equipInfo.name} (Lv.${cardLevel})</strong><br>
                <span class="materials-list">æ•ˆæœ: ${statsText}</span>
              </div>
            `;
          }
        }
      }
    
      equipEl.innerHTML = html;
    }

    // ğŸ†• åˆ‡æ›å‰¯æœ¬åˆ†é¡ä¸‹æ‹‰é¸å–®ï¼ˆå®Œå…¨ä¿®å¾©ç‰ˆï¼‰
    function toggleDungeonDropdown() {
      const dropdown = document.getElementById("dungeonDropdown");
      const dropdownBtn = document.querySelector('[data-category="dungeon"]');
      
      console.log('ğŸ”§ å‰¯æœ¬åˆ†é¡æŒ‰éˆ•è¢«é»æ“Š');
      console.log('ä¸‹æ‹‰é¸å–®å…ƒç´ :', dropdown);
      console.log('ç•¶å‰ç‹€æ…‹:', isDungeonDropdownOpen);
      
      if (!dropdown) {
        console.error('âŒ æ‰¾ä¸åˆ° dungeonDropdown å…ƒç´ ');
        return;
      }
      
      // ğŸ”§ ç›´æ¥åˆ‡æ›é¡¯ç¤ºç‹€æ…‹
      isDungeonDropdownOpen = !isDungeonDropdownOpen;
      
      if (isDungeonDropdownOpen) {
        dropdown.classList.add("show");
        dropdownBtn?.classList.add("expanded");
        console.log('âœ… ä¸‹æ‹‰é¸å–®å·²å±•é–‹');
        console.log('dropdown classes:', dropdown.classList.toString());
      } else {
        dropdown.classList.remove("show");
        dropdownBtn?.classList.remove("expanded");
        console.log('âœ… ä¸‹æ‹‰é¸å–®å·²æ”¶èµ·');
        console.log('dropdown classes:', dropdown.classList.toString());
      }
    }

    // é“å…·åˆ†é¡éæ¿¾å‡½æ•¸ (æ›´æ–°ç‰ˆ)
    function filterItems(category) {
      currentCategory = category;
      
      // ğŸš€ ä¿®å¾©ï¼šç¢ºä¿ category è½‰æ›ç‚ºå­—ç¬¦ä¸²é€²è¡Œæ¯”è¼ƒ
      const categoryStr = String(category);
      
      // ğŸ†• è™•ç†å‰¯æœ¬åˆ†é¡çš„ç‰¹æ®Šé‚è¼¯
      if (categoryStr.startsWith('dungeon_')) {
        // å‰¯æœ¬åˆ†é¡è¢«é¸ä¸­ï¼Œä¿æŒä¸‹æ‹‰é¸å–®é–‹å•Ÿ
        const belongValue = parseInt(categoryStr.split('_')[1]);
        
        // æ›´æ–°å‰¯æœ¬æŒ‰éˆ•ç‹€æ…‹
        document.querySelectorAll('.dungeon-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-belong="${belongValue}"]`).classList.add('active');
        
        // æ›´æ–°ä¸»åˆ†é¡æŒ‰éˆ•ç‹€æ…‹ - å‰¯æœ¬åˆ†é¡æŒ‰éˆ•ä¿æŒæ¿€æ´»
        document.querySelectorAll('.category-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector('[data-category="dungeon"]').classList.add('active');
        
      } else {
        // éå‰¯æœ¬åˆ†é¡ï¼Œé—œé–‰ä¸‹æ‹‰é¸å–®
        if (isDungeonDropdownOpen) {
          const dropdown = document.getElementById("dungeonDropdown");
          const dropdownBtn = document.querySelector('[data-category="dungeon"]');
          dropdown?.classList.remove("show");
          dropdownBtn?.classList.remove("expanded");
          isDungeonDropdownOpen = false;
          console.log('ğŸ”„ åˆ‡æ›åˆ°å…¶ä»–åˆ†é¡ï¼Œä¸‹æ‹‰é¸å–®å·²é—œé–‰');
        }
        
        // æ¸…é™¤å‰¯æœ¬æŒ‰éˆ•ç‹€æ…‹
        document.querySelectorAll('.dungeon-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        
        // æ›´æ–°ä¸»åˆ†é¡æŒ‰éˆ•ç‹€æ…‹
        document.querySelectorAll('.category-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-category="${category}"]`).classList.add('active');
      }
      
      // é‡æ–°æ¸²æŸ“é“å…·åˆ—è¡¨
      renderItems();
    }

    // è¨ˆç®—å„åˆ†é¡çš„é“å…·æ•¸é‡ (æ›´æ–°ç‰ˆ)
    function calculateCategoryStats() {
      const stats = {
        all: 0,
        1: 0,   // ç¨€æœ‰
        2: 0,   // è¶…ç¨€æœ‰
        3: 0,   // ç½•è¦‹
        0: 0,   // æ™®é€š
        dungeons: {} // å‰¯æœ¬åˆ†é¡çµ±è¨ˆ
      };
      
      // åˆå§‹åŒ–å‰¯æœ¬çµ±è¨ˆ
      Object.keys(dungeonNames).forEach(belongId => {
        stats.dungeons[belongId] = 0;
      });
      
      Object.entries(userItems).forEach(([id, count]) => {
        if (count > 0) {
          const meta = itemMeta.find(m => m.id === id) || { special: 0, belong: 0 };
          const special = meta.special || 0;
          const belong = meta.belong || 0;
          
          stats.all++;
          stats[special]++;
          
          // çµ±è¨ˆå‰¯æœ¬é“å…·
          if (belong > 0 && stats.dungeons.hasOwnProperty(belong)) {
            stats.dungeons[belong]++;
          }
        }
      });
      
      return stats;
    }

    // æ›´æ–°åˆ†é¡çµ±è¨ˆé¡¯ç¤º (æ›´æ–°ç‰ˆ)
    function updateCategoryStats() {
      const statsEl = document.getElementById("categoryStats");
      const stats = calculateCategoryStats();
      
      let displayText = "";
      
      if (currentCategory === 'all') {
        const total = stats.all;
        const rare = stats[1] || 0;
        const superRare = stats[2] || 0;
        const mythical = stats[3] || 0;
        const normal = stats[0] || 0;
        
        displayText = `å…± ${total} ç¨®é“å…· (æ™®é€š: ${normal}, ç¨€æœ‰: ${rare}, è¶…ç¨€æœ‰: ${superRare}, ç½•è¦‹: ${mythical})`;
        
      } else if (String(currentCategory).startsWith('dungeon_')) {
        const belongValue = parseInt(String(currentCategory).split('_')[1]);
        const dungeonName = dungeonNames[belongValue];
        const count = stats.dungeons[belongValue] || 0;
        displayText = `${dungeonName}é“å…·: ${count} ç¨®`;
        
      } else {
        const categoryNames = {
          1: "ç¨€æœ‰",
          2: "è¶…ç¨€æœ‰", 
          3: "ç½•è¦‹"
        };
        const categoryName = categoryNames[Number(currentCategory)];
        const count = stats[Number(currentCategory)] || 0;
        displayText = `${categoryName}é“å…·: ${count} ç¨®`;
      }
      
      statsEl.textContent = displayText;
    }

    // ğŸ”§ ä¿®æ”¹ renderItems å‡½æ•¸ä»¥æ”¯æ´åˆ†é¡éæ¿¾å’Œæ’åº
    function renderItems() {
      const itemEl = document.getElementById("itemGrid");
      let html = "";
      let displayedCount = 0;
      
      // ğŸš€ å»ºç«‹é“å…·é™£åˆ—ä¸¦æŒ‰ sort æ’åºï¼ˆç”±å¤§åˆ°å°ï¼‰
      const itemsArray = [];
      
      Object.entries(userItems).forEach(([id, count]) => {
        if (count > 0) {
          const meta = itemMeta.find(m => m.id === id) || { name: id, description: "", special: 0, belong: 0, sort: 0 };
          
          // ğŸ”§ åˆ†é¡éæ¿¾é‚è¼¯ - ä¿®å¾©æ•¸å­—/å­—ç¬¦ä¸²æ¯”è¼ƒå•é¡Œ
          let shouldShow = false;
          
          if (currentCategory === 'all') {
            shouldShow = true;
          } else if (String(currentCategory).startsWith('dungeon_')) {
            const belongValue = parseInt(String(currentCategory).split('_')[1]);
            shouldShow = (meta.belong === belongValue);
          } else {
            // ç¢ºä¿æ•¸å­—æ¯”è¼ƒæ­£ç¢º
            shouldShow = (meta.special === Number(currentCategory));
          }
          
          if (shouldShow) {
            itemsArray.push({
              id: id,
              count: count,
              meta: meta
            });
          }
        }
      });
      
      // ğŸš€ æŒ‰ sort æ’åºï¼ˆç”±å¤§åˆ°å°ï¼‰
      itemsArray.sort((a, b) => {
        const sortA = a.meta.sort || 0;
        const sortB = b.meta.sort || 0;
        return sortB - sortA; // ç”±å¤§åˆ°å°æ’åº
      });
      
      // ğŸ¨ æ¸²æŸ“é“å…·å¡ç‰‡
      itemsArray.forEach(item => {
        const { id, count, meta } = item;
        
        let cardClass = "item-card";
        let rarityLabel = "";
        let nameColor = "#D0D0D0";
        
        if (meta.special === 1) {
          cardClass += " rare";
          rarityLabel = "ã€ç¨€æœ‰ã€‘";
          nameColor = "#00bfff";
        } else if (meta.special === 2) {
          cardClass += " super-rare";
          rarityLabel = "ã€è¶…ç¨€æœ‰ã€‘";
          nameColor = "#ff69b4";
        } else if (meta.special === 3) {
          cardClass += " mythical";
          rarityLabel = "ã€ç½•è¦‹ã€‘";
          nameColor = "#FFD306";
        }
        
        // ğŸ·ï¸ æ·»åŠ å‰¯æœ¬æ¨™ç±¤ï¼ˆç•¶ä¸æ˜¯åœ¨å‰¯æœ¬åˆ†é¡æ¨¡å¼æ™‚é¡¯ç¤ºï¼‰
        let dungeonLabel = "";
        if (!String(currentCategory).startsWith('dungeon_') && meta.belong > 0 && dungeonNames[meta.belong]) {
          dungeonLabel = ` - ${dungeonNames[meta.belong]}`;
        }
    
        html += `
          <div class="${cardClass}">
            <div class="item-name" style="color: ${nameColor}">${rarityLabel}${meta.name}${dungeonLabel}</div>
            <div class="item-desc">${meta.description}</div>
            <div class="item-count">æŒæœ‰æ•¸é‡: <span class="count-highlight">${count}</span></div>
          </div>
        `;
        
        displayedCount++;
      });
    
      // æ›´æ–°çµ±è¨ˆé¡¯ç¤º
      updateCategoryStats();
      
      if (displayedCount === 0) {
        let categoryName = 'é“å…·';
        
        if (String(currentCategory).startsWith('dungeon_')) {
          const belongValue = parseInt(String(currentCategory).split('_')[1]);
          categoryName = dungeonNames[belongValue] + 'é“å…·';
        } else {
          const categoryNames = {
            'all': 'é“å…·',
            1: 'ç¨€æœ‰é“å…·',
            2: 'è¶…ç¨€æœ‰é“å…·', 
            3: 'ç½•è¦‹é“å…·'
          };
          categoryName = categoryNames[currentCategory] || 'é“å…·';
        }
        
        html = `<div class="item-card">æš«ç„¡${categoryName}</div>`;
      }
      
      itemEl.innerHTML = html;
    }

    function renderPage() {
      renderStats();
      renderEquipment();
      renderItems();
    }

    // ğŸš€ å„ªåŒ–çš„å¡ç‰‡ç­‰ç´šåŒæ­¥
    async function syncEquippedCardLevels(upgradedCardId, newLevel) {
      const equipment = userData.equipment || {};
      let needsUpdate = false;
      const newEquipment = { ...equipment };
      
      for (let slot = 1; slot <= 5; slot++) {
        const slotEquip = equipment[slot];
        if (slotEquip && typeof slotEquip === 'object') {
          const equippedCardId = Object.keys(slotEquip)[0];
          if (equippedCardId === upgradedCardId) {
            newEquipment[slot] = { [upgradedCardId]: newLevel };
            needsUpdate = true;
            console.log(`ğŸ“ æº–å‚™æ›´æ–°æ’æ§½ ${slot} çš„ ${upgradedCardId} ç­‰ç´šè‡³ ${newLevel}`);
          }
        }
      }
      
      if (needsUpdate) {
        try {
          
          const response = await SecureAPI.post(`${API_BASE}/save_equipment`, {
            equipment: newEquipment
          });
          
          const result = await response.json();
          
          if (response.ok && result.success) {
            userData.equipment = newEquipment;
            
            // ç«‹å³é‡æ–°æ¸²æŸ“ä¸€æ¬¡ç¢ºä¿é¡¯ç¤ºæ­£ç¢º
            renderEquipment();
            renderStats();
            
          } else {
            console.error("âŒ åŒæ­¥è£å‚™ç­‰ç´šå¤±æ•—:", result.error || result.message);
            
            // å¦‚æœåŒæ­¥å¤±æ•—ï¼Œå›æ»¾æœ¬åœ°è³‡æ–™
            console.log("åŒæ­¥å¤±æ•—ï¼Œé‡æ–°è¼‰å…¥ä¼ºæœå™¨è³‡æ–™...");
            await loadUserData();
          }
        } catch (error) {
          console.error("âŒ åŒæ­¥è£å‚™ç­‰ç´šæ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
          
          // å¦‚æœåŒæ­¥å¤±æ•—ï¼Œé‡æ–°è¼‰å…¥ä¼ºæœå™¨è³‡æ–™
          console.log("åŒæ­¥éŒ¯èª¤ï¼Œé‡æ–°è¼‰å…¥ä¼ºæœå™¨è³‡æ–™...");
          await loadUserData();
        }
      }
    }

    async function openCraftUI() {
      PerformanceMonitor.startTiming('openCraftUI');
      
      // è¼‰å…¥å¤±æ•—æ¬¡æ•¸è³‡æ–™
      await loadCardFailureCounts();
      
      const dialog = document.getElementById("dialogContainer");
      
      let html = `
        <div class='dialog-box'>
          <h3>ğŸ’» å¡ç‰‡è£½ä½œèˆ‡å‡ç´š</h3>
          <div class="scroll-content">
      `;
      
      cardData.forEach(card => {
        const currentLevel = userCards[card.id] || 0;
        const maxLevel = card.levels.length;
        const isMaxed = currentLevel >= maxLevel;
        const canCraft = userData.level >= card.require_level;
        
        if (!canCraft) {
          html += `
            <div class="craft-item">
              <strong>${card.name}</strong> (éœ€è¦ç­‰ç´š: ${card.require_level})<br>
              <span style="color: red;">ç­‰ç´šä¸è¶³ï¼Œç„¡æ³•è£½ä½œ</span>
            </div>
          `;
          return;
        }
        
        const nextLevel = currentLevel + 1;
        const levelData = card.levels[currentLevel];
        
        if (isMaxed) {
          html += `
            <div class="craft-item">
              <strong>${card.name}</strong> Lv.${currentLevel} (å·²æ»¿ç´š)<br>
              <span class="materials-list">${card.description}</span>
            </div>
          `;
        } else if (levelData) {
          const materials = Object.entries(levelData.materials)
          .map(([matId, qty]) => {
            const owned = userItems[matId] || 0;
            const color = owned >= qty ? "green" : "red";
            const meta = itemMeta.find(m => m.id === matId);
            const itemName = meta ? meta.name : matId;
            return `<span style="color: ${color}">${itemName} x${qty} (${owned})</span>`;
          }).join(", ");
          
          const hasAllMaterials = Object.entries(levelData.materials)
            .every(([matId, qty]) => (userItems[matId] || 0) >= qty);
          
          // å–å¾—å¤±æ•—æ¬¡æ•¸ä¸¦è¨ˆç®—å¼·åŒ–æˆåŠŸç‡
          const failureCount = cardFailureCounts[card.id] || 0;
          const baseSuccessRate = levelData.chance;
          const successRateDisplay = formatSuccessRateDisplay(baseSuccessRate, failureCount);
          const isGuaranteed = calculateEnhancedSuccessRate(baseSuccessRate, failureCount) >= 1.0;
          
          html += `
            <div class="craft-item">
              <strong>${card.name}</strong> Lv.${currentLevel} â†’ Lv.${nextLevel}<br>
              <span class="materials-list">${card.description}</span><br>
              <span class="materials-list">æ‰€éœ€ææ–™: ${materials}</span><br>
              <div class="success-rate-display">${successRateDisplay}</div>
              ${hasAllMaterials ? 
                `<button class="square-btn ${isGuaranteed ? 'guaranteed-craft-btn' : ''}" onclick="craftCard('${card.id}', ${currentLevel})">${currentLevel === 0 ? 'è£½ä½œ' : 'å‡ç´š'}${isGuaranteed ? ' (å¿…å®šæˆåŠŸ!)' : ''}</button>` :
                '<span style="color: red">ææ–™ä¸è¶³</span>'
              }
            </div>
          `;
        }
      });
      
      html += `
          </div>
          <div class="btn-group">
            <button class="square-btn" onclick="closeDialog()">é—œé–‰</button>
          </div>
        </div>
      `;
      
      dialog.innerHTML = html;
      dialog.style.display = "flex";
      document.body.style.overflow = "hidden";
      document.body.classList.add("dialog-open");
      
      PerformanceMonitor.endTiming('openCraftUI');
    }

    // å¡ç‰‡è£½ä½œ
    async function craftCard(cardId, currentLevel) {
      const card = cardData.find(c => c.id === cardId);
      const levelData = card.levels[currentLevel];
      
      if (!levelData) {
        alert("âŒ è³‡æ–™éŒ¯èª¤");
        return;
      }
      
      for (const [matId, qty] of Object.entries(levelData.materials)) {
        const ownedQty = userItems[String(matId)] || 0;
        if (ownedQty < qty) {
          alert(`âŒ ææ–™ä¸è¶³ï¼š${matId} éœ€è¦ ${qty}ï¼ŒæŒæœ‰ ${ownedQty}`);
          return;
        }
      }
      
      // è¨ˆç®—ä¸¦é¡¯ç¤ºå¼·åŒ–æˆåŠŸç‡
      const failureCount = cardFailureCounts[cardId] || 0;
      const baseSuccessRate = levelData.chance;
      const enhancedSuccessRate = calculateEnhancedSuccessRate(baseSuccessRate, failureCount);
      const enhancedPercentage = (enhancedSuccessRate * 100).toFixed(0);
      
      let confirmMessage = `ç¢ºå®šè¦${currentLevel === 0 ? 'è£½ä½œ' : 'å‡ç´š'} ${card.name} å—ï¼Ÿ\n`;
      
      if (enhancedSuccessRate >= 1.0) {
        confirmMessage += `âœ¨ å¿…å®šæˆåŠŸï¼(100%)`;
      } else {
        confirmMessage += `æˆåŠŸç‡: ${enhancedPercentage}%`;
        if (failureCount > 0) {
          confirmMessage += `\n(åŸºç¤ ${(baseSuccessRate * 100).toFixed(0)}% + å¤±æ•—åŠ æˆ ${failureCount * 5}%)`;
        }
      }
      
      if (!confirm(confirmMessage)) {
        return;
      }
      
      showLoading(true);
      
      try {
        const response = await SecureAPI.post(`${API_BASE}/craft_card`, {
          card_id: cardId,
          materials: levelData.materials,
          success_rate: levelData.chance
        });
        
        const result = await response.json();
        
        if (response.ok) {
          if (result.success) {
            // æˆåŠŸè™•ç†
            let successMsg = result.message;
            if (result.failure_count_reset && result.previous_failure_count > 0) {
              successMsg += `\nğŸ‰ å¤±æ•—æ¬¡æ•¸å·²é‡ç½®ï¼(ä¹‹å‰ç´¯ç© ${result.previous_failure_count} æ¬¡å¤±æ•—)`;
            }
            alert(`âœ… ${successMsg}`);
            
            const newLevel = currentLevel + 1;
            userCards[cardId] = newLevel;
            
            // é‡ç½®æœ¬åœ°å¤±æ•—æ¬¡æ•¸è¨˜éŒ„
            if (cardFailureCounts[cardId]) {
              delete cardFailureCounts[cardId];
            }
            
            // ç«‹å³æ›´æ–°æœ¬åœ°è£å‚™è³‡æ–™
            updateLocalEquipmentLevels(cardId, newLevel);
            
            // åŒæ­¥è£å‚™ç­‰ç´šåˆ°ä¼ºæœå™¨
            try {
              await syncEquippedCardLevels(cardId, newLevel);
            } catch (syncError) {
              console.error("åŒæ­¥è£å‚™ç­‰ç´šæ™‚ç™¼ç”ŸéŒ¯èª¤:", syncError);
            }
            
            // å¼·åˆ¶æ¸…é™¤æ‰€æœ‰ç›¸é—œå¿«å–
            await forceRefreshAllData();
            
          } else {
            // å¤±æ•—è™•ç†
            let failMsg = result.message;
            if (result.failure_count && result.next_success_rate) {
              const nextRate = (result.next_success_rate * 100).toFixed(0);
              failMsg += `\n å¤±æ•—æ¬¡æ•¸: ${result.failure_count}`;
              failMsg += `\n ä¸‹æ¬¡æˆåŠŸç‡: ${nextRate}% (+${result.bonus_rate}% åŠ æˆ)`;
              
              // æ›´æ–°æœ¬åœ°å¤±æ•—æ¬¡æ•¸è¨˜éŒ„
              cardFailureCounts[cardId] = result.failure_count;
            }
            alert(`âŒ ${failMsg}`);
            
            // è£½ä½œå¤±æ•—ä¹Ÿè¦æ¸…é™¤å¿«å–ä¸¦é‡æ–°è¼‰å…¥ï¼Œå› ç‚ºææ–™å·²ç¶“è¢«æ¶ˆè€—
            await forceRefreshAllData();
          }
          
          closeDialog();
          
        } else {
          alert(result.error || "è£½ä½œå¤±æ•—");
        }
      } catch (error) {
        console.error("è£½ä½œéŒ¯èª¤:", error);
        alert("è£½ä½œéç¨‹ç™¼ç”ŸéŒ¯èª¤");
      } finally {
        showLoading(false);
      }
    }

    async function forceRefreshAllData() {
      
      try {
        // æ¸…é™¤å‰ç«¯æ‰€æœ‰å¿«å–
        SecureAPI.clearCache();
        
        // ç™¼é€å¾Œç«¯å¿«å–æ¸…é™¤è«‹æ±‚ï¼ˆå¯é¸ï¼Œé‡å°åš´é‡å¿«å–å•é¡Œï¼‰
        try {
          await fetch(`${API_BASE}/clear_cache`, { method: 'POST' });
        } catch (cacheError) {
          console.warn("å¾Œç«¯å¿«å–æ¸…é™¤å¤±æ•—:", cacheError);
        }
        
        // ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿å¿«å–æ¸…é™¤å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // å¼·åˆ¶é‡æ–°è¼‰å…¥æ‰€æœ‰ä½¿ç”¨è€…è³‡æ–™
        await loadUserData();
        
        // é‡æ–°æ¸²æŸ“æ‰€æœ‰é¡¯ç¤º
        renderPage();
        
      } catch (error) {
        console.error("å¼·åˆ¶åˆ·æ–°è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
        // å¦‚æœè‡ªå‹•åˆ·æ–°å¤±æ•—ï¼Œæç¤ºä½¿ç”¨è€…æ‰‹å‹•é‡æ–°æ•´ç†
        if (confirm("è³‡æ–™åŒæ­¥å¯èƒ½æœ‰å•é¡Œï¼Œæ˜¯å¦è¦é‡æ–°æ•´ç†é é¢ç¢ºä¿è³‡æ–™ä¸€è‡´æ€§ï¼Ÿ")) {
          window.location.reload();
        }
      }
    }

    
    // é©—è­‰è£å‚™ç­‰ç´šä¸€è‡´æ€§
    async function validateAndFixEquipmentLevels() {
      const equipment = userData.equipment || {};
      let needsUpdate = false;
      const newEquipment = { ...equipment };
      
      for (let slot = 1; slot <= 5; slot++) {
        const slotEquip = equipment[slot];
        if (slotEquip && typeof slotEquip === 'object') {
          const equippedCardId = Object.keys(slotEquip)[0];
          const equippedLevel = slotEquip[equippedCardId];
          const actualLevel = userCards[equippedCardId] || 0;
          
          if (actualLevel > 0 && equippedLevel < actualLevel) {
            newEquipment[slot] = { [equippedCardId]: actualLevel };
            needsUpdate = true;
            console.log(`ä¿®å¾©æ’æ§½ ${slot} çš„ ${equippedCardId} ç­‰ç´šï¼š${equippedLevel} â†’ ${actualLevel}`);
          }
        }
      }
      
      if (needsUpdate) {
        try {
          const response = await SecureAPI.post(`${API_BASE}/save_equipment`, {
            equipment: newEquipment
          });
          
          const result = await response.json();
          
          if (response.ok && result.success) {
            userData.equipment = newEquipment;
            renderPage();
          }
        } catch (error) {
          console.error("âŒ è‡ªå‹•ä¿®å¾©è£å‚™ç­‰ç´šæ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
        }
      }
    }

    function openEquipUI() {
      PerformanceMonitor.startTiming('openEquipUI');
      
      const dialog = document.getElementById("dialogContainer");
      const equipment = userData.equipment || {};
    
      const equippedCardIds = new Set();
      for (let slot = 1; slot <= 5; slot++) {
        const slotEquip = equipment[slot];
        if (slotEquip) {
          const cardId = Object.keys(slotEquip)[0];
          equippedCardIds.add(cardId);
        }
      }
    
      let html = `
        <div class='dialog-box'>
          <h3>ğŸ›°ï¸ å¡ç‰‡é‘²åµŒèˆ‡æ’æ§½ç®¡ç†</h3>
      `;
    
      const selectIds = [];
    
      for (let slot = 1; slot <= 5; slot++) {
        const equippedCardId = equipment[slot] ? Object.keys(equipment[slot])[0] : "";
        const equippedLevel = equippedCardId ? userCards[equippedCardId] : 0;
        selectIds.push(`equip_slot_${slot}`);
    
        html += `
          <div class="equip-item">
            <label><strong>æ¬„ä½ ${slot}:</strong></label><br>
            <select id="equip_slot_${slot}" style="width: 100%; margin-top: 5px;" data-slot="${slot}">
              <option value="">ç„¡è£å‚™</option>
        `;
    
        Object.entries(userCards).forEach(([cardId, level]) => {
          if (level > 0) {
            const cardInfo = equipData.find(e => e.id === cardId);
            const cardName = cardInfo ? cardInfo.name : cardId;
            const selected = (equippedCardId === cardId) ? 'selected' : '';
            html += `<option value="${cardId}" ${selected}>${cardName} Lv.${level}</option>`;
          }
        });
    
        html += `
            </select>
          </div>
        `;
      }
    
      html += `
          <div class="btn-group">
            <button class="square-btn" onclick="saveEquipment()">âœ… å„²å­˜æ’æ§½</button>
            <button class="square-btn" onclick="closeDialog()">å–æ¶ˆ</button>
          </div>
        </div>
      `;
    
      dialog.innerHTML = html;
      dialog.style.display = "flex";
      document.body.style.overflow = "hidden";
      document.body.classList.add("dialog-open");
    
      selectIds.forEach(id => {
        const select = document.getElementById(id);
        select.addEventListener("change", () => {
          updateEquipDropdowns(selectIds);
        });
      });
    
      updateEquipDropdowns(selectIds);
      PerformanceMonitor.endTiming('openEquipUI');
    }

    function updateLocalEquipmentLevels(cardId, newLevel) {
      
      const equipment = userData.equipment || {};
      let updated = false;
      
      for (let slot = 1; slot <= 5; slot++) {
        const equippedCard = equipment[slot];
        if (equippedCard && typeof equippedCard === 'object') {
          const equippedCardId = Object.keys(equippedCard)[0];
          if (equippedCardId === cardId) {
            // ç«‹å³æ›´æ–°æœ¬åœ°è³‡æ–™
            userData.equipment[slot] = { [cardId]: newLevel };
            updated = true;
          }
        }
      }
      
      if (updated) {
        // ç«‹å³é‡æ–°æ¸²æŸ“é é¢
        renderEquipment();
        renderStats();
      }
    }

    function updateEquipDropdowns(selectIds) {
      const selectedValues = selectIds.map(id => document.getElementById(id).value);
    
      selectIds.forEach((id, idx) => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        const slot = select.dataset.slot;
        
        const newOptions = [`<option value="">ç„¡è£å‚™</option>`];
    
        Object.entries(userCards).forEach(([cardId, level]) => {
          if (level <= 0) return;
    
          const cardInfo = equipData.find(e => e.id === cardId);
          const cardName = cardInfo ? cardInfo.name : cardId;
    
          const isSelectedElsewhere = selectedValues.some((val, i) => i !== idx && val === cardId);
          const isCurrent = currentValue === cardId;
    
          if (!isSelectedElsewhere || isCurrent) {
            newOptions.push(`<option value="${cardId}" ${isCurrent ? "selected" : ""}>${cardName} Lv.${level}</option>`);
          }
        });
    
        select.innerHTML = newOptions.join("");
      });
    }

    // å„²å­˜è£å‚™åŠŸèƒ½
    async function saveEquipment() {
      const newEquipment = {};
      const usedCardIds = new Set();
    
      for (let slot = 1; slot <= 5; slot++) {
        const selectEl = document.getElementById(`equip_slot_${slot}`);
        const cardId = selectEl.value;
    
        if (cardId) {
          if (usedCardIds.has(cardId)) {
            alert(`âŒ åŒä¸€å¼µå¡ç‰‡ã€Œ${cardId}ã€ä¸èƒ½è£å‚™åœ¨å¤šå€‹æ¬„ä½`);
            return;
          }
          usedCardIds.add(cardId);
          newEquipment[slot] = { [cardId]: userCards[cardId] };
        }
      }
    
      showLoading(true);
    
      try {
        const response = await SecureAPI.post(`${API_BASE}/save_equipment`, {
          equipment: newEquipment
        });
    
        const result = await response.json();
    
        if (response.ok && result.success) {
          userData.equipment = newEquipment;
          
          // ğŸ§¹ æ¸…é™¤å¿«å–
          SecureAPI.clearUserCache();
          
          renderPage();
          closeDialog();
          alert("âœ… æ’æ§½æ›´æ–°æˆåŠŸ");
        } else {
          alert(result.error || result.message || "æ’æ§½æ›´æ–°å¤±æ•—");
        }
      } catch (error) {
        console.error("å„²å­˜æ’æ§½éŒ¯èª¤:", error);
        alert("å„²å­˜æ’æ§½æ™‚ç™¼ç”ŸéŒ¯èª¤");
      } finally {
        showLoading(false);
      }
    }

    // ğŸ”§ æ¸¬è©¦å‡½æ•¸
    function testDropdown() {
      console.log('ğŸ§ª æ¸¬è©¦ä¸‹æ‹‰é¸å–®åŠŸèƒ½');
      console.log('isDungeonDropdownOpen:', isDungeonDropdownOpen);
      const dropdown = document.getElementById("dungeonDropdown");
      console.log('dropdown å…ƒç´ :', dropdown);
      console.log('dropdown ç•¶å‰ classes:', dropdown.classList.toString());
      
      // å¼·åˆ¶åˆ‡æ›ä¸‹æ‹‰é¸å–®
      toggleDungeonDropdown();
    }

    function closeDialog() {
      document.body.style.overflow = "";
      document.body.classList.remove("dialog-open");
      document.getElementById("dialogContainer").style.display = "none";
    }

    // å…¨åŸŸå‡½æ•¸
    window.openCraftUI = openCraftUI;
    window.openEquipUI = openEquipUI;
    window.closeDialog = closeDialog;
    window.craftCard = craftCard;
    window.saveEquipment = saveEquipment;
    window.filterItems = filterItems;
    window.toggleDungeonDropdown = toggleDungeonDropdown;

    // ä¸»è¦åˆå§‹åŒ–å‡½æ•¸
    async function runMain() {
      showLoading(true);
      
      try {
        PerformanceMonitor.startTiming('totalLoad');
        
        // ä¸¦è¡Œè¼‰å…¥éŠæˆ²è³‡æ–™å’Œä½¿ç”¨è€…è³‡æ–™
        await Promise.all([
          loadGameData(),
          loadUserData(),
          loadCardFailureCounts() 
        ]);
        
        PerformanceMonitor.endTiming('totalLoad');
        
      } catch (error) {
        console.error("åˆå§‹åŒ–éŒ¯èª¤:", error);
        alert("é é¢åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†");
      } finally {
        showLoading(false);
      }
    }

    // ç›£è½ç™»å…¥ç‹€æ…‹
    onAuthStateChanged(auth, (user) => {
      if (user) {
        runMain();
      } else {
        window.parent.location.href = "/SFL/login.html";
      }
    });

    // ğŸ†• é»æ“Šå¤–éƒ¨é—œé–‰å‰¯æœ¬ä¸‹æ‹‰é¸å–®
    document.addEventListener('click', function(event) {
      const dropdown = document.getElementById("dungeonDropdown");
      const dropdownBtn = document.querySelector('[data-category="dungeon"]');
      
      if (isDungeonDropdownOpen && 
          !dropdown.contains(event.target) && 
          !dropdownBtn.contains(event.target)) {
        dropdown.classList.remove("show");
        dropdownBtn.classList.remove("expanded");
        isDungeonDropdownOpen = false;
        console.log('âœ… é»æ“Šå¤–éƒ¨ï¼Œä¸‹æ‹‰é¸å–®å·²é—œé–‰');
      }
    });

    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        
        // é é¢é‡æ–°å¯è¦‹æ™‚ï¼Œè¼•é‡ç´šæª¢æŸ¥è³‡æ–™æ˜¯å¦éœ€è¦æ›´æ–°
        setTimeout(async () => {
          try {
            // åªé‡æ–°è¼‰å…¥ä½¿ç”¨è€…ç‹€æ…‹ï¼Œä¸å¼·åˆ¶åˆ·æ–°å¿«å–
            const latestUser = await SecureAPI.getStatus(false);
            const latestUserData = await latestUser.json();
            
            // æ¯”è¼ƒè£å‚™è³‡æ–™æ˜¯å¦æœ‰è®ŠåŒ–
            const currentEquipment = JSON.stringify(userData.equipment);
            const latestEquipment = JSON.stringify(latestUserData.equipment);
            
            if (currentEquipment !== latestEquipment) {
              userData = latestUserData;
              renderEquipment();
              renderStats();
            }
          } catch (error) {
            console.warn("é é¢å¯è¦‹æ€§æª¢æŸ¥å¤±æ•—:", error);
          }
        }, 1000);
      }
    });
    
    // ğŸš€ æ–°å¢ï¼šé–‹ç™¼è€…åµéŒ¯å·¥å…·
    if (window.location.hostname === 'localhost' || window.location.search.includes('debug=true')) {
      window.inventoryDebug = {
        // å¼·åˆ¶åˆ·æ–°æ‰€æœ‰è³‡æ–™
        forceRefresh: () => forceRefreshAllData(),
        
        // æª¢æŸ¥è³‡æ–™ä¸€è‡´æ€§
        checkConsistency: () => {
          console.log("ğŸ” æª¢æŸ¥è³‡æ–™ä¸€è‡´æ€§...");
          console.log("ä½¿ç”¨è€…å¡ç‰‡:", userCards);
          console.log("è£å‚™ç‹€æ…‹:", userData.equipment);
          
          // æª¢æŸ¥è£å‚™ä¸­çš„å¡ç‰‡ç­‰ç´šæ˜¯å¦èˆ‡æ“æœ‰çš„å¡ç‰‡ç­‰ç´šä¸€è‡´
          for (let slot = 1; slot <= 5; slot++) {
            const equippedCard = userData.equipment[slot];
            if (equippedCard) {
              const cardId = Object.keys(equippedCard)[0];
              const equippedLevel = equippedCard[cardId];
              const ownedLevel = userCards[cardId] || 0;
              
              if (equippedLevel !== ownedLevel) {
                console.warn(`âš ï¸ æ’æ§½ ${slot} ç­‰ç´šä¸ä¸€è‡´: è£å‚™=${equippedLevel}, æ“æœ‰=${ownedLevel}`);
              }
            }
          }
        },
        
        // æ‰‹å‹•åŒæ­¥è£å‚™ç­‰ç´š
        syncAll: async () => {
          for (const [cardId, level] of Object.entries(userCards)) {
            await syncEquippedCardLevels(cardId, level);
          }
        },
        
        // æ¸¬è©¦åˆ†é¡åŠŸèƒ½
        testCategory: (category) => {
          console.log(`ğŸ§ª æ¸¬è©¦åˆ†é¡åŠŸèƒ½: ${category}`);
          filterItems(category);
        },
        
        // æ¸¬è©¦å‰¯æœ¬åˆ†é¡
        testDungeonCategory: (belongId) => {
          console.log(`ğŸ§ª æ¸¬è©¦å‰¯æœ¬åˆ†é¡: belong=${belongId}`);
          filterItems(`dungeon_${belongId}`);
        },
        
        // æŸ¥çœ‹ç•¶å‰åˆ†é¡çµ±è¨ˆ
        showCategoryStats: () => {
          const stats = calculateCategoryStats();
          console.log('ğŸ“Š åˆ†é¡çµ±è¨ˆ:', stats);
          console.table(stats.dungeons);
        },
        
        // ğŸ”§ æ¸¬è©¦ä¸‹æ‹‰é¸å–®
        testDropdown: testDropdown
      };
      
      console.log("ğŸ”§ èƒŒåŒ…åµéŒ¯å·¥å…·å·²å•Ÿç”¨ï¼Œä½¿ç”¨ inventoryDebug å­˜å–");
    }
  </script>
</body>
</html>
