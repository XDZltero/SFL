<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>背包與裝備管理</title>
  <link rel="icon" href="favicon.ico" />
  <link href="css/inventory.css" rel="stylesheet"/>
</head>
<body>
  <div id="initialOverlay">載入中...</div>
  <div id="loading-placeholder"></div>
  <script src="js/loading.js"></script>
  <script>
    fetch("loadingOverlay.html")
      .then(res => res.text())
      .then(html => {
        document.getElementById("loading-placeholder").innerHTML = html;
        document.getElementById("initialOverlay")?.remove();
        if (typeof startPageLoadingProgress === "function") startPageLoadingProgress();
      });
  </script>

  <h1 class="fancy-title">🌌 卡片矩陣系統</h1>
  <div class="top-grid">
    <div class="stats-section">
      <h2 class="fancy-subtitle">🧬 角色屬性</h2>
      <div id="statsDisplay"></div>
    </div>
    
    <div class="equipment-section">
      <h2 class="fancy-subtitle">📁 卡片插槽</h2>
      <div id="equipmentDisplay"></div>
    </div>
  </div>
  
  <div class="btn-group">
    <button class="square-btn" onclick="openCraftUI()">💻 製作終端</button>
    <button class="square-btn" onclick="openEquipUI()">🛰️ 插槽管理</button>
  </div>
  
  <div class="items-section">
    <h2 class="fancy-subtitle">📦 持有道具</h2>
    <div class="item-grid" id="itemGrid"></div>
  </div>
  
  <div id="dialogContainer"></div>
  <div id="loadingSpinner" class="loading-spinner">處理中...</div>

  <script type="module">
    import { auth, SecureAPI, PerformanceMonitor } from "./js/firebase-init.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    const API_BASE = "https://sfl-9cb8.onrender.com";
    let userData = {};
    let userItems = {};
    let equipData = [];
    let itemMeta = [];
    let cardData = [];
    let userCards = {};
    let cardFailureCounts = {};

    function showLoading(show) {
      const loading = document.getElementById("loadingOverlay");
      const spinner = document.getElementById("loadingSpinner");
      if (loading) loading.style.display = show ? "flex" : "none";
      if (spinner) spinner.style.display = show ? "block" : "none";
    }

    // 遊戲資料載入
    async function loadGameData() {
      PerformanceMonitor.startTiming('loadGameData');
      
      try {
        // 並行載入所有靜態資料，使用快取
        const [equipRes, itemRes, cardRes] = await Promise.all([
          SecureAPI.getStaticData('equips_table'),
          SecureAPI.getStaticData('items_table'), 
          SecureAPI.getStaticData('cards_data')
        ]);
        
        equipData = Array.isArray(equipRes) ? equipRes : Object.values(equipRes);
        
        // 處理 items 資料格式
        if (Array.isArray(itemRes)) {
          itemMeta = itemRes;
        } else if (typeof itemRes === 'object') {
          itemMeta = Object.values(itemRes);
        } else {
          throw new Error('無效的道具資料格式');
        }
        
        // cardData
        try {
          const cardResponse = await fetch("parameter/cards_data.json");
          cardData = await cardResponse.json();
        } catch (error) {
          console.warn('載入卡片資料失敗，使用空陣列:', error);
          cardData = [];
        }
        
        console.log('✅ 遊戲資料載入完成');
        
      } catch (error) {
        console.error("載入遊戲資料失敗:", error);
        alert("載入遊戲資料失敗，請重新整理頁面");
        throw error;
      } finally {
        PerformanceMonitor.endTiming('loadGameData');
      }
    }

    async function loadCardFailureCounts() {
      try {
        const response = await SecureAPI.get(`${API_BASE}/card_failure_counts`, true);
        if (response && response.ok) {
          cardFailureCounts = await response.json();
        } else {
          cardFailureCounts = {};
        }
      } catch (error) {
        console.error("載入卡片失敗次數失敗:", error);
        cardFailureCounts = {};
      }
    }

    function calculateEnhancedSuccessRate(baseRate, failureCount) {
      const enhancedRate = baseRate + (failureCount * 0.05);
      return Math.min(enhancedRate, 1.0); // 最高100%
    }

    // 格式化成功率顯示
    function formatSuccessRateDisplay(baseRate, failureCount) {
      const enhancedRate = calculateEnhancedSuccessRate(baseRate, failureCount);
      const enhancedPercentage = (enhancedRate * 100).toFixed(0);
      const bonusPercentage = failureCount * 5;
      
      let html = `<span class="craft-success-rate">成功率: `;
      
      if (enhancedRate >= 1.0) {
        // 100% 必定成功
        html += `<span class="guaranteed-success">必定成功 ${enhancedPercentage}%</span>`;
      } else {
        html += `${enhancedPercentage}%`;
      }
      
      if (failureCount > 0) {
        html += ` <span class="failure-bonus">(失敗加成 ${failureCount} 次：成功率增加 ${bonusPercentage}%)</span>`;
      }
      
      html += `</span>`;
      return html;
    }


    async function loadUserData(forceRefresh = true) {
      PerformanceMonitor.startTiming('loadUserData');
      
      try {
        console.log(`🔄 載入使用者資料 ${forceRefresh ? '(強制刷新)' : '(允許快取)'}`);
        
        // 🎯 強制從伺服器重新獲取資料
        const promises = [
          SecureAPI.getStatus(forceRefresh),
          SecureAPI.get(`${API_BASE}/user_items`, !forceRefresh), // 如果forceRefresh=true，則useCache=false
          SecureAPI.get(`${API_BASE}/user_cards`, !forceRefresh)
        ];
        
        const [statusRes, itemsRes, cardsRes] = await Promise.all(promises);
        
        // 處理使用者狀態
        userData = await statusRes.json();
        console.log("✅ 使用者狀態已載入");
        
        // 處理使用者道具
        if (itemsRes && itemsRes.ok) {
          userItems = await itemsRes.json();
          console.log("✅ 使用者道具已載入");
        } else {
          userItems = userData.items || {};
          console.log("⚠️ 使用備用道具資料");
        }
        
        // 處理使用者卡片
        if (cardsRes && cardsRes.ok) {
          userCards = await cardsRes.json();
          console.log("✅ 使用者卡片已載入");
        } else {
          userCards = userData.cards_owned || {};
          console.log("⚠️ 使用備用卡片資料");
        }
        
        // 🔧 驗證並修復裝備等級不一致問題
        await validateAndFixEquipmentLevels();
        
        renderPage();
        
        console.log('✅ 使用者資料載入完成');
        
      } catch (error) {
        console.error("載入使用者資料失敗:", error);
        
        // 如果載入失敗，嘗試重新載入但允許快取
        if (forceRefresh) {
          console.log("🔄 強制載入失敗，嘗試使用快取資料...");
          try {
            await loadUserData(false);
          } catch (fallbackError) {
            console.error("連快取載入也失敗:", fallbackError);
            alert("載入使用者資料失敗，請重新整理頁面");
          }
        } else {
          alert("載入使用者資料失敗");
          throw error;
        }
      } finally {
        PerformanceMonitor.endTiming('loadUserData');
      }
    }

    function calculateEquipmentBonus() {
      const bonus = {};
      const equipment = userData.equipment || {};
      
      for (let slot = 1; slot <= 5; slot++) {
        const equippedCard = equipment[slot];
        if (!equippedCard) continue;
        
        const cardId = Object.keys(equippedCard)[0];
        const cardLevel = equippedCard[cardId];
        const equipInfo = equipData.find(e => e.id === cardId);
        
        if (equipInfo && equipInfo.value && equipInfo.value[cardLevel]) {
          const cardStats = equipInfo.value[cardLevel];
          for (const [stat, value] of Object.entries(cardStats)) {
            bonus[stat] = (bonus[stat] || 0) + value;
          }
        }
      }
      
      return bonus;
    }

    function renderStats() {
      const baseStats = userData.base_stats || {};
      const equipBonus = calculateEquipmentBonus(userData.equipment || {}, equipData);
      const statsEl = document.getElementById("statsDisplay");
      
      const statsList = [
        { key: "hp", label: "生命值", isPercent: false },
        { key: "attack", label: "攻擊力", isPercent: false },
        { key: "shield", label: "護盾值", isPercent: false },
        { key: "evade", label: "迴避率", isPercent: true },
        { key: "accuracy", label: "命中率", isPercent: true },
        { key: "other_bonus", label: "額外傷害加成", isPercent: true },
        { key: "luck", label: "幸運值", isPercent: false },
        { key: "atk_speed", label: "攻擊速度", isPercent: false },
        { key: "penetrate", label: "護盾穿透", isPercent: false }
      ];
      
      let html = "";
      statsList.forEach(({ key, label, isPercent }) => {
        const base = baseStats[key] || 0;
        const bonus = equipBonus[key] || 0;
        const total = base + bonus;
        
        const displayValue = isPercent ? `${(total * 100).toFixed(1)}%` : total;
        const bonusDisplay = bonus > 0 ? ` (+${isPercent ? (bonus * 100).toFixed(1) + '%' : bonus})` : '';
        
        html += `
          <div class="stat-item">
            <span>${label}:</span>
            <span>${displayValue} (${isPercent ? (base * 100).toFixed(1) + '%' : base}${bonusDisplay})</span>
          </div>
        `;
      });
      
      statsEl.innerHTML = html;
    }

    function renderEquipment() {
      const equipment = userData.equipment || {};
      const equipEl = document.getElementById("equipmentDisplay");
      
      let html = "";
      for (let slot = 1; slot <= 5; slot++) {
        const equippedCard = equipment[slot];
        
        if (!equippedCard) {
          html += `
            <div class="equipment-slot empty">
              欄位 ${slot}: 無裝備
            </div>
          `;
        } else {
          const cardId = Object.keys(equippedCard)[0];
          const cardLevel = equippedCard[cardId];
          const equipInfo = equipData.find(e => e.id === cardId);
    
          const statNameMap = {
            hp: "生命值",
            attack: "攻擊力",
            shield: "護盾",
            evade: "閃避",
            accuracy: "命中",
            luck: "運氣",
            atk_speed: "攻擊速度",
            other_bonus: "其他加成"
          };
    
          if (equipInfo && equipInfo.value && equipInfo.value[cardLevel]) {
            const stats = equipInfo.value[cardLevel]; 
            const statsText = Object.entries(stats)
              .map(([key, value]) => {
                const label = statNameMap[key] || key;
                const displayValue = ['evade','accuracy','other_bonus'].includes(key)
                  ? `+${(value * 100).toFixed(1)}%`
                  : `+${value}`;
                return `${label}: ${displayValue}`;
              })
              .join(", ");
              
            html += `
              <div class="equipment-slot">
                <strong>欄位 ${slot}: ${equipInfo.name} (Lv.${cardLevel})</strong><br>
                <span class="materials-list">效果: ${statsText}</span>
              </div>
            `;
          }
        }
      }
    
      equipEl.innerHTML = html;
    }

    function renderItems() {
      const itemEl = document.getElementById("itemGrid");
      let html = "";
    
      Object.entries(userItems).forEach(([id, count]) => {
        const meta = itemMeta.find(m => m.id === id) || { name: id, description: "", special: 0 };

        let cardClass = "item-card";
        let rarityLabel = "";
        let nameColor = "#D0D0D0";
        
        if (meta.special === 1) {
          cardClass += " rare";
          rarityLabel = "【稀有】";
          nameColor = "#00bfff";
        } else if (meta.special === 2) {
          cardClass += " super-rare";
          rarityLabel = "【超稀有】";
          nameColor = "#ff69b4";
        } else if (meta.special === 3) {
          cardClass += " mythical";
          rarityLabel = "【罕見】";
          nameColor = "##FFD306";
        }
    
        html += `
          <div class="${cardClass}">
            <div class="item-name" style="color: ${nameColor}">${rarityLabel}${meta.name}</div>
            <div class="item-desc">${meta.description}</div>
            <div class="item-count">持有數量: <span class="count-highlight">${count}</span></div>
          </div>
        `;
      });
    
      itemEl.innerHTML = html || '<div class="item-card">暫無道具</div>';
    }

    function renderPage() {
      renderStats();
      renderEquipment();
      renderItems();
    }

    // 🚀 優化的卡片等級同步
    async function syncEquippedCardLevels(upgradedCardId, newLevel) {
      const equipment = userData.equipment || {};
      let needsUpdate = false;
      const newEquipment = { ...equipment };
      
      for (let slot = 1; slot <= 5; slot++) {
        const slotEquip = equipment[slot];
        if (slotEquip && typeof slotEquip === 'object') {
          const equippedCardId = Object.keys(slotEquip)[0];
          if (equippedCardId === upgradedCardId) {
            newEquipment[slot] = { [upgradedCardId]: newLevel };
            needsUpdate = true;
            console.log(`📝 準備更新插槽 ${slot} 的 ${upgradedCardId} 等級至 ${newLevel}`);
          }
        }
      }
      
      if (needsUpdate) {
        try {
          console.log("🔄 正在同步裝備等級到伺服器...");
          
          const response = await SecureAPI.post(`${API_BASE}/save_equipment`, {
            equipment: newEquipment
          });
          
          const result = await response.json();
          
          if (response.ok && result.success) {
            userData.equipment = newEquipment;
            console.log("✅ 已同步更新裝備卡片等級到伺服器");
            
            // 🔄 立即重新渲染一次確保顯示正確
            renderEquipment();
            renderStats();
            
          } else {
            console.error("❌ 同步裝備等級失敗:", result.error || result.message);
            
            // 如果同步失敗，回滾本地資料
            console.log("🔄 同步失敗，重新載入伺服器資料...");
            await loadUserData();
          }
        } catch (error) {
          console.error("❌ 同步裝備等級時發生錯誤:", error);
          
          // 如果同步失敗，重新載入伺服器資料
          console.log("🔄 同步錯誤，重新載入伺服器資料...");
          await loadUserData();
        }
      }
    }

    async function openCraftUI() {
      PerformanceMonitor.startTiming('openCraftUI');
      
      // 載入失敗次數資料
      await loadCardFailureCounts();
      
      const dialog = document.getElementById("dialogContainer");
      
      let html = `
        <div class='dialog-box'>
          <h3>💻 卡片製作與升級</h3>
          <div class="scroll-content">
      `;
      
      cardData.forEach(card => {
        const currentLevel = userCards[card.id] || 0;
        const maxLevel = card.levels.length;
        const isMaxed = currentLevel >= maxLevel;
        const canCraft = userData.level >= card.require_level;
        
        if (!canCraft) {
          html += `
            <div class="craft-item">
              <strong>${card.name}</strong> (需要等級: ${card.require_level})<br>
              <span style="color: red;">等級不足，無法製作</span>
            </div>
          `;
          return;
        }
        
        const nextLevel = currentLevel + 1;
        const levelData = card.levels[currentLevel];
        
        if (isMaxed) {
          html += `
            <div class="craft-item">
              <strong>${card.name}</strong> Lv.${currentLevel} (已滿級)<br>
              <span class="materials-list">${card.description}</span>
            </div>
          `;
        } else if (levelData) {
          const materials = Object.entries(levelData.materials)
          .map(([matId, qty]) => {
            const owned = userItems[matId] || 0;
            const color = owned >= qty ? "green" : "red";
            const meta = itemMeta.find(m => m.id === matId);
            const itemName = meta ? meta.name : matId;
            return `<span style="color: ${color}">${itemName} x${qty} (${owned})</span>`;
          }).join(", ");
          
          const hasAllMaterials = Object.entries(levelData.materials)
            .every(([matId, qty]) => (userItems[matId] || 0) >= qty);
          
          // 取得失敗次數並計算強化成功率
          const failureCount = cardFailureCounts[card.id] || 0;
          const baseSuccessRate = levelData.chance;
          const successRateDisplay = formatSuccessRateDisplay(baseSuccessRate, failureCount);
          const isGuaranteed = calculateEnhancedSuccessRate(baseSuccessRate, failureCount) >= 1.0;
          
          html += `
            <div class="craft-item">
              <strong>${card.name}</strong> Lv.${currentLevel} → Lv.${nextLevel}<br>
              <span class="materials-list">${card.description}</span><br>
              <span class="materials-list">所需材料: ${materials}</span><br>
              <div class="success-rate-display">${successRateDisplay}</div>
              ${hasAllMaterials ? 
                `<button class="square-btn ${isGuaranteed ? 'guaranteed-craft-btn' : ''}" onclick="craftCard('${card.id}', ${currentLevel})">${currentLevel === 0 ? '製作' : '升級'}${isGuaranteed ? ' (必定成功!)' : ''}</button>` :
                '<span style="color: red">材料不足</span>'
              }
            </div>
          `;
        }
      });
      
      html += `
          </div>
          <div class="btn-group">
            <button class="square-btn" onclick="closeDialog()">關閉</button>
          </div>
        </div>
      `;
      
      dialog.innerHTML = html;
      dialog.style.display = "flex";
      document.body.style.overflow = "hidden";
      document.body.classList.add("dialog-open");
      
      PerformanceMonitor.endTiming('openCraftUI');
    }

    // 卡片製作
    async function craftCard(cardId, currentLevel) {
      const card = cardData.find(c => c.id === cardId);
      const levelData = card.levels[currentLevel];
      
      if (!levelData) {
        alert("❌ 資料錯誤");
        return;
      }
      
      for (const [matId, qty] of Object.entries(levelData.materials)) {
        const ownedQty = userItems[String(matId)] || 0;
        if (ownedQty < qty) {
          alert(`❌ 材料不足：${matId} 需要 ${qty}，持有 ${ownedQty}`);
          return;
        }
      }
      
      // 計算並顯示強化成功率
      const failureCount = cardFailureCounts[cardId] || 0;
      const baseSuccessRate = levelData.chance;
      const enhancedSuccessRate = calculateEnhancedSuccessRate(baseSuccessRate, failureCount);
      const enhancedPercentage = (enhancedSuccessRate * 100).toFixed(0);
      
      let confirmMessage = `確定要${currentLevel === 0 ? '製作' : '升級'} ${card.name} 嗎？\n`;
      
      if (enhancedSuccessRate >= 1.0) {
        confirmMessage += `✨ 必定成功！(100%)`;
      } else {
        confirmMessage += `成功率: ${enhancedPercentage}%`;
        if (failureCount > 0) {
          confirmMessage += `\n(基礎 ${(baseSuccessRate * 100).toFixed(0)}% + 失敗加成 ${failureCount * 5}%)`;
        }
      }
      
      if (!confirm(confirmMessage)) {
        return;
      }
      
      showLoading(true);
      
      try {
        const response = await SecureAPI.post(`${API_BASE}/craft_card`, {
          card_id: cardId,
          materials: levelData.materials,
          success_rate: levelData.chance
        });
        
        const result = await response.json();
        
        if (response.ok) {
          if (result.success) {
            // 成功處理
            let successMsg = result.message;
            if (result.failure_count_reset && result.previous_failure_count > 0) {
              successMsg += `\n🎉 失敗次數已重置！(之前累積 ${result.previous_failure_count} 次失敗)`;
            }
            alert(`✅ ${successMsg}`);
            
            const newLevel = currentLevel + 1;
            userCards[cardId] = newLevel;
            
            // 重置本地失敗次數記錄
            if (cardFailureCounts[cardId]) {
              delete cardFailureCounts[cardId];
            }
            
            // 立即更新本地裝備資料
            updateLocalEquipmentLevels(cardId, newLevel);
            
            // 同步裝備等級到伺服器
            try {
              await syncEquippedCardLevels(cardId, newLevel);
            } catch (syncError) {
              console.error("同步裝備等級時發生錯誤:", syncError);
            }
            
            // 強制清除所有相關快取
            await forceRefreshAllData();
            
          } else {
            // 失敗處理
            let failMsg = result.message;
            if (result.failure_count && result.next_success_rate) {
              const nextRate = (result.next_success_rate * 100).toFixed(0);
              failMsg += `\n 失敗次數: ${result.failure_count}`;
              failMsg += `\n 下次成功率: ${nextRate}% (+${result.bonus_rate}% 加成)`;
              
              // 更新本地失敗次數記錄
              cardFailureCounts[cardId] = result.failure_count;
            }
            alert(`❌ ${failMsg}`);
            
            // 製作失敗也要清除快取並重新載入，因為材料已經被消耗
            await forceRefreshAllData();
          }
          
          closeDialog();
          
        } else {
          alert(result.error || "製作失敗");
        }
      } catch (error) {
        console.error("製作錯誤:", error);
        alert("製作過程發生錯誤");
      } finally {
        showLoading(false);
      }
    }

    async function forceRefreshAllData() {
      
      try {
        // 清除前端所有快取
        SecureAPI.clearCache();
        
        // 發送後端快取清除請求（可選，針對嚴重快取問題）
        try {
          await fetch(`${API_BASE}/clear_cache`, { method: 'POST' });
        } catch (cacheError) {
          console.warn("後端快取清除失敗:", cacheError);
        }
        
        // 等待一小段時間確保快取清除完成
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // 強制重新載入所有使用者資料
        await loadUserData();
        
        // 重新渲染所有顯示
        renderPage();
        
      } catch (error) {
        console.error("強制刷新資料時發生錯誤:", error);
        // 如果自動刷新失敗，提示使用者手動重新整理
        if (confirm("資料同步可能有問題，是否要重新整理頁面確保資料一致性？")) {
          window.location.reload();
        }
      }
    }

    
    // 🔧 驗證裝備等級一致性
    async function validateAndFixEquipmentLevels() {
      const equipment = userData.equipment || {};
      let needsUpdate = false;
      const newEquipment = { ...equipment };
      
      for (let slot = 1; slot <= 5; slot++) {
        const slotEquip = equipment[slot];
        if (slotEquip && typeof slotEquip === 'object') {
          const equippedCardId = Object.keys(slotEquip)[0];
          const equippedLevel = slotEquip[equippedCardId];
          const actualLevel = userCards[equippedCardId] || 0;
          
          if (actualLevel > 0 && equippedLevel < actualLevel) {
            newEquipment[slot] = { [equippedCardId]: actualLevel };
            needsUpdate = true;
            console.log(`修復插槽 ${slot} 的 ${equippedCardId} 等級：${equippedLevel} → ${actualLevel}`);
          }
        }
      }
      
      if (needsUpdate) {
        try {
          const response = await SecureAPI.post(`${API_BASE}/save_equipment`, {
            equipment: newEquipment
          });
          
          const result = await response.json();
          
          if (response.ok && result.success) {
            userData.equipment = newEquipment;
            console.log("✅ 已自動修復裝備等級不一致問題");
            renderPage();
          }
        } catch (error) {
          console.error("❌ 自動修復裝備等級時發生錯誤:", error);
        }
      }
    }

    function openEquipUI() {
      PerformanceMonitor.startTiming('openEquipUI');
      
      const dialog = document.getElementById("dialogContainer");
      const equipment = userData.equipment || {};
    
      const equippedCardIds = new Set();
      for (let slot = 1; slot <= 5; slot++) {
        const slotEquip = equipment[slot];
        if (slotEquip) {
          const cardId = Object.keys(slotEquip)[0];
          equippedCardIds.add(cardId);
        }
      }
    
      let html = `
        <div class='dialog-box'>
          <h3>🛰️ 卡片鑲嵌與插槽管理</h3>
      `;
    
      const selectIds = [];
    
      for (let slot = 1; slot <= 5; slot++) {
        const equippedCardId = equipment[slot] ? Object.keys(equipment[slot])[0] : "";
        const equippedLevel = equippedCardId ? userCards[equippedCardId] : 0;
        selectIds.push(`equip_slot_${slot}`);
    
        html += `
          <div class="equip-item">
            <label><strong>欄位 ${slot}:</strong></label><br>
            <select id="equip_slot_${slot}" style="width: 100%; margin-top: 5px;" data-slot="${slot}">
              <option value="">無裝備</option>
        `;
    
        Object.entries(userCards).forEach(([cardId, level]) => {
          if (level > 0) {
            const cardInfo = equipData.find(e => e.id === cardId);
            const cardName = cardInfo ? cardInfo.name : cardId;
            const selected = (equippedCardId === cardId) ? 'selected' : '';
            html += `<option value="${cardId}" ${selected}>${cardName} Lv.${level}</option>`;
          }
        });
    
        html += `
            </select>
          </div>
        `;
      }
    
      html += `
          <div class="btn-group">
            <button class="square-btn" onclick="saveEquipment()">✅ 儲存插槽</button>
            <button class="square-btn" onclick="closeDialog()">取消</button>
          </div>
        </div>
      `;
    
      dialog.innerHTML = html;
      dialog.style.display = "flex";
      document.body.style.overflow = "hidden";
      document.body.classList.add("dialog-open");
    
      selectIds.forEach(id => {
        const select = document.getElementById(id);
        select.addEventListener("change", () => {
          updateEquipDropdowns(selectIds);
        });
      });
    
      updateEquipDropdowns(selectIds);
      PerformanceMonitor.endTiming('openEquipUI');
    }

    function updateLocalEquipmentLevels(cardId, newLevel) {
      console.log(`🔄 立即更新本地裝備資料：${cardId} -> Lv.${newLevel}`);
      
      const equipment = userData.equipment || {};
      let updated = false;
      
      for (let slot = 1; slot <= 5; slot++) {
        const equippedCard = equipment[slot];
        if (equippedCard && typeof equippedCard === 'object') {
          const equippedCardId = Object.keys(equippedCard)[0];
          if (equippedCardId === cardId) {
            // 立即更新本地資料
            userData.equipment[slot] = { [cardId]: newLevel };
            updated = true;
            console.log(`✅ 已更新插槽 ${slot} 的 ${cardId} 等級至 ${newLevel}`);
          }
        }
      }
      
      if (updated) {
        // 立即重新渲染頁面
        renderEquipment();
        renderStats();
        console.log("🔄 已立即更新顯示");
      }
    }

    function updateEquipDropdowns(selectIds) {
      const selectedValues = selectIds.map(id => document.getElementById(id).value);
    
      selectIds.forEach((id, idx) => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        const slot = select.dataset.slot;
        
        const newOptions = [`<option value="">無裝備</option>`];
    
        Object.entries(userCards).forEach(([cardId, level]) => {
          if (level <= 0) return;
    
          const cardInfo = equipData.find(e => e.id === cardId);
          const cardName = cardInfo ? cardInfo.name : cardId;
    
          const isSelectedElsewhere = selectedValues.some((val, i) => i !== idx && val === cardId);
          const isCurrent = currentValue === cardId;
    
          if (!isSelectedElsewhere || isCurrent) {
            newOptions.push(`<option value="${cardId}" ${isCurrent ? "selected" : ""}>${cardName} Lv.${level}</option>`);
          }
        });
    
        select.innerHTML = newOptions.join("");
      });
    }

    // 🚀 優化的儲存裝備功能
    async function saveEquipment() {
      const newEquipment = {};
      const usedCardIds = new Set();
    
      for (let slot = 1; slot <= 5; slot++) {
        const selectEl = document.getElementById(`equip_slot_${slot}`);
        const cardId = selectEl.value;
    
        if (cardId) {
          if (usedCardIds.has(cardId)) {
            alert(`❌ 同一張卡片「${cardId}」不能裝備在多個欄位`);
            return;
          }
          usedCardIds.add(cardId);
          newEquipment[slot] = { [cardId]: userCards[cardId] };
        }
      }
    
      showLoading(true);
    
      try {
        const response = await SecureAPI.post(`${API_BASE}/save_equipment`, {
          equipment: newEquipment
        });
    
        const result = await response.json();
    
        if (response.ok && result.success) {
          userData.equipment = newEquipment;
          
          // 🧹 清除快取
          SecureAPI.clearUserCache();
          
          renderPage();
          closeDialog();
          alert("✅ 插槽更新成功");
        } else {
          alert(result.error || result.message || "插槽更新失敗");
        }
      } catch (error) {
        console.error("儲存插槽錯誤:", error);
        alert("儲存插槽時發生錯誤");
      } finally {
        showLoading(false);
      }
    }

    function closeDialog() {
      document.body.style.overflow = "";
      document.body.classList.remove("dialog-open");
      document.getElementById("dialogContainer").style.display = "none";
    }

    // 全域函數
    window.openCraftUI = openCraftUI;
    window.openEquipUI = openEquipUI;
    window.closeDialog = closeDialog;
    window.craftCard = craftCard;
    window.saveEquipment = saveEquipment;

    // 主要初始化函數
    async function runMain() {
      showLoading(true);
      
      try {
        PerformanceMonitor.startTiming('totalLoad');
        
        // 並行載入遊戲資料和使用者資料
        await Promise.all([
          loadGameData(),
          loadUserData(),
          loadCardFailureCounts() 
        ]);
        
        PerformanceMonitor.endTiming('totalLoad');
        console.log('🎉 背包頁面初始化完成（包含失敗次數系統）');
        
      } catch (error) {
        console.error("初始化錯誤:", error);
        alert("頁面初始化失敗，請重新整理");
      } finally {
        showLoading(false);
      }
    }

    // 監聽登入狀態
    onAuthStateChanged(auth, (user) => {
      if (user) {
        runMain();
      } else {
        window.parent.location.href = "/SFL/login.html";
      }
    });

    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        console.log("🔄 頁面重新可見，檢查資料一致性...");
        
        // 頁面重新可見時，輕量級檢查資料是否需要更新
        setTimeout(async () => {
          try {
            // 只重新載入使用者狀態，不強制刷新快取
            const latestUser = await SecureAPI.getStatus(false);
            const latestUserData = await latestUser.json();
            
            // 比較裝備資料是否有變化
            const currentEquipment = JSON.stringify(userData.equipment);
            const latestEquipment = JSON.stringify(latestUserData.equipment);
            
            if (currentEquipment !== latestEquipment) {
              console.log("⚠️ 檢測到裝備資料變化，更新顯示...");
              userData = latestUserData;
              renderEquipment();
              renderStats();
            }
          } catch (error) {
            console.warn("頁面可見性檢查失敗:", error);
          }
        }, 1000);
      }
    });
    
    // 🚀 新增：開發者偵錯工具
    if (window.location.hostname === 'localhost' || window.location.search.includes('debug=true')) {
      window.inventoryDebug = {
        // 強制刷新所有資料
        forceRefresh: () => forceRefreshAllData(),
        
        // 檢查資料一致性
        checkConsistency: () => {
          console.log("🔍 檢查資料一致性...");
          console.log("使用者卡片:", userCards);
          console.log("裝備狀態:", userData.equipment);
          
          // 檢查裝備中的卡片等級是否與擁有的卡片等級一致
          for (let slot = 1; slot <= 5; slot++) {
            const equippedCard = userData.equipment[slot];
            if (equippedCard) {
              const cardId = Object.keys(equippedCard)[0];
              const equippedLevel = equippedCard[cardId];
              const ownedLevel = userCards[cardId] || 0;
              
              if (equippedLevel !== ownedLevel) {
                console.warn(`⚠️ 插槽 ${slot} 等級不一致: 裝備=${equippedLevel}, 擁有=${ownedLevel}`);
              }
            }
          }
        },
        
        // 手動同步裝備等級
        syncAll: async () => {
          for (const [cardId, level] of Object.entries(userCards)) {
            await syncEquippedCardLevels(cardId, level);
          }
        }
      };
      
      console.log("🔧 背包偵錯工具已啟用，使用 inventoryDebug 存取");
    }
  </script>
</body>
</html>
